## 1.有如下的四个/24地址块，试进行最大可能的聚合

```
212.56.132.0/24	
212.56.133.0/24	
212.56.134.0/24	
212.65.135.0/24
```



解答：

为了最大可能地聚合给定的四个/24地址块，我们需要找到它们可以合并的最小公共子网。具体步骤如下：

1. 确定地址的二进制表示：
   - 212.56.132.0/24: 11010100 00111000 10000100 00000000
   - 212.56.133.0/24: 11010100 00111000 10000101 00000000
   - 212.56.134.0/24: 11010100 00111000 10000110 00000000
   - 212.65.135.0/24: 11010100 00111111 10000111 00000000

2. 比较前缀：
   找出所有地址的最长公共前缀。

   - 212.56.132.0 和 212.56.133.0: 11010100 00111000 1000010 (23 bits)
   - 212.56.134.0 和前两个相同: 11010100 00111000 100001 (22 bits)
   - 212.65.135.0 与前面三个地址前缀不同，仅前12 bits相同: 11010100 0011 (12 bits)

3. 确定聚合：
   - **由于第四个地址块(212.65.135.0/24)与前三个地址块的前缀不同，我们不能将所有四个地址块聚合在一起。**
   - 前三个地址块(212.56.132.0/24, 212.56.133.0/24, 212.56.134.0/24)有22位的共同前缀，可以聚合成一个/22的地址块。

综上所述，最大的聚合结果为：

- 212.56.132.0/22 包含 212.56.132.0/24, 212.56.133.0/24 和 212.56.134.0/24。
- 212.65.135.0/24 无法与其他地址块聚合。

所以，最大可能的聚合结果是：

```
212.56.132.0/22
212.65.135.0/24
```



## 2.一个UDP用户数据报的数据部分为4192B，该分组应该被划分成几个IP分片？说明每一个IP分片的数据部分长度、分片偏移量的值以及MF比特的取值。



总数据长度：
- 数据部分为4192字节 + UDP首部8字节 = 4200字节。

每个分片的数据部分长度：
- 由于IP分片的数据部分必须是8字节的倍数，并且以太网环境下，每个IP分片的数据部分的最大长度为1500 - 20 = 1480字节，我们需要确保分片的数据部分长度是8字节的倍数。因此，我们选择每个分片的数据部分长度为最大1480字节的倍数中的8字节倍数，即1480字节。

计算分片数量：
- 分片数 = ceil(4200 / 1480) = 3个分片。

分片细节

第一个分片：
- 数据部分长度：1480字节
- 分片偏移量：0
- MF比特：1（表示后续还有分片）

第二个分片：
- 数据部分长度：1480字节
- 分片偏移量：1480 / 8 = 185
- MF比特：1（表示后续还有分片）

第三个分片：
- 剩余数据长度：4200 - 2 * 1480 = 1240字节
- 数据部分长度：1240字节
- 分片偏移量：2 * 1480 / 8 = 370
- MF比特：0（表示这是最后一个分片）

总结

- 第一个IP分片：
  - 数据部分长度：1480字节
  - 分片偏移量：0
  - MF比特：1

- 第二个IP分片：
  - 数据部分长度：1480字节
  - 分片偏移量：185
  - MF比特：1

- 第三个IP分片：
  - 数据部分长度：1240字节
  - 分片偏移量：370
  - MF比特：0

这样，每个IP分片的数据部分长度都是8字节的倍数，并且考虑到了UDP首部。



**相似的题**

假设一个 UDP 用户数据报的数据部分为 4392 字节，UDP 用户数据报传送过程中要经过以太网络，以太网的
MTU 为 1500 字节，网络层使用 IP 协议对 UDP 用户数据报进行封装，使用 20 字节的 IP 固定首部，试问 IP 分
组应该被划分为几个 IP 分片？说明每一个分片的数据部分长度、分片偏移量的值以及 MF 比特的取值

> MTU（Maximum Transmission Unit）是指网络层在链路上传输的最大数据包大小，通常是针对数据链路层的帧的限制。对于以太网，标准的MTU为1500字节，这包括了IP数据报，但不包括以太网帧头和尾。

为了将一个UDP用户数据报的数据部分（4392字节）划分为多个IP分片，我们需要考虑以太网MTU（最大传输单元）和IP协议的要求。

分析步骤

1. **确定IP数据报总长度：**
   - UDP用户数据报数据部分：4392字节
   - UDP首部：8字节
   - 总数据长度：4392 + 8 = 4400字节

2. **以太网MTU和IP分片：**
   - 以太网MTU为1500字节，其中20字节为IP固定首部。因此，每个IP分片的数据部分最大长度为1500 - 20 = 1480字节。
   - IP分片的数据部分必须是8字节的倍数。

计算分片

每个分片的数据部分长度

- 数据部分的最大长度为1480字节且必须是8字节的倍数，所以可以直接使用1480字节。

计算需要的分片数量

- 数据部分总长度为4400字节。
- 每个分片的数据部分长度为1480字节。
- 分片数量 = ceil(4400 / 1480) = ceil(2.972) ≈ 3个分片。

分片细节

**第一个分片：**
- 数据部分长度：1480字节
- 分片偏移量：0
- MF比特：1（表示后续还有分片）

**第二个分片：**
- 数据部分长度：1480字节
- 分片偏移量：1480 / 8 = 185
- MF比特：1（表示后续还有分片）

**第三个分片：**
- 剩余数据长度：4400 - 2 * 1480 = 1440字节
- 数据部分长度：1440字节（是8的倍数）
- 分片偏移量：2 * 1480 / 8 = 370
- MF比特：0（表示这是最后一个分片）

总结

- **第一个IP分片：**
  - 数据部分长度：1480字节
  - 分片偏移量：0
  - MF比特：1

- **第二个IP分片：**
  - 数据部分长度：1480字节
  - 分片偏移量：185
  - MF比特：1

- **第三个IP分片：**
  - 数据部分长度：1440字节
  - 分片偏移量：370
  - MF比特：0

这样，每个IP分片的数据部分长度都是8字节的倍数，并且符合以太网MTU的要求。





## 3.一个A类网络和一个B类网络的子网号分别为16位1和8位1.分别写出这两个网络的子网掩码。这两个子网掩码所代表的意义有什么不同？

一个A类网络和一个B类网络的子网号分别为16位1和8位1，这些子网掩码有不同的表示和意义。

A类网络的子网掩码

一个A类网络默认的子网掩码是255.0.0.0，也就是只有前8位为1（前8位表示网络号）。

如果子网号为16位1，即子网掩码为：

```
11111111.11111111.00000000.00000000
```

转换为十进制表示为：

```
255.255.0.0
```

B类网络的子网掩码

一个B类网络默认的子网掩码是255.255.0.0，也就是前16位为1（前16位表示网络号）。

如果子网号为8位1，即子网掩码为：

```
11111111.11111111.11111111.00000000
```

转换为十进制表示为：

```
255.255.255.0
```

子网掩码的意义

1. **A类网络的子网掩码（255.255.0.0）**：
   - **默认子网掩码**：255.0.0.0
   - **子网掩码扩展到16位**：255.255.0.0
   - **意义**：前16位（网络号 + 子网号）标识网络地址，后16位标识主机地址。
   - **作用**：将一个A类网络划分为多个子网，每个子网有2^16 - 2个主机地址（去掉全0和全1的地址）。

2. **B类网络的子网掩码（255.255.255.0）**：
   - **默认子网掩码**：255.255.0.0
   - **子网掩码扩展到24位**：255.255.255.0
   - **意义**：前24位（网络号 + 子网号）标识网络地址，后8位标识主机地址。
   - **作用**：将一个B类网络划分为多个子网，每个子网有2^8 - 2个主机地址（去掉全0和全1的地址）。

总结

- **A类网络子网掩码（255.255.0.0）**：将一个A类网络划分为更多的子网，每个子网有较多的主机。
- **B类网络子网掩码（255.255.255.0）**：将一个B类网络划分为更多的子网，每个子网有较少的主机。

这种划分方式让网络管理员可以灵活地管理和优化网络资源，根据实际需求调整网络和子网的大小。

1. **网络号（Network Address）**：
   - 网络号是IP地址中用于标识特定网络的那部分。在IP地址的分级结构中，网络号用于区分不同的网络。
   - 在A、B、C类IP地址中，网络号的长度是固定的，分别为8位、16位和24位。
2. **主机号（Host Address）**：
   - 主机号是IP地址中用于标识特定网络内特定主机的那部分。在每个网络内，主机号必须是唯一的。
   - 例如，在C类IP地址（192.168.1.0/24）中，前24位是网络号，最后8位是主机号。
3. **子网号（Subnet Address）**：
   - 子网号是从主机号中借用一部分来创建子网的。通过子网划分，一个大的网络可以被划分为多个小的子网。
   - 子网号用于标识特定的子网，而子网内的主机号用于标识子网内的特定设备。
4. **子网掩码（Subnet Mask）**：
   - 子网掩码是一个32位的数字，用于区分IP地址中的网络号、子网号和主机号。
   - 子网掩码通常用点分十进制表示，其中网络和子网部分为255（二进制的11111111），主机部分为0或255。
   - 例如，子网掩码255.255.255.0表示前24位是网络和子网号，最后8位是主机号。



## 4.若一个网络的子网掩码为255.255.255.248，则每个子网能够连接多少台主机

为了计算一个子网掩码为255.255.255.248的网络中每个子网能够连接多少台主机，需要了解子网掩码的细节以及如何通过子网掩码计算出主机数。

子网掩码255.255.255.248对应的二进制表示是：
```
11111111.11111111.11111111.11111000
```
这里有29位是1，这意味着网络部分占用29位，主机部分占用剩下的3位。

主机部分有3位，这意味着可以表示2^3 = 8个地址。但是，需要减去2个地址：
1. 全0的地址表示网络地址
2. 全1的地址表示广播地址

因此，每个子网的可用主机数计算如下：
```
2^3 - 2 = 8 - 2 = 6
```

一个子网掩码为255.255.255.248的子网可以连接6台主机。



## 5.写出IPv4地址202.196.75.18的IPv6兼容地址，用十六进制表示



IPv6兼容地址是一种特殊的IPv6地址格式，它允许IPv4地址嵌入在IPv6地址中。这种格式通常用于IPv4到IPv6的过渡和兼容性。IPv6兼容地址的格式是`::/96`，即前96位为0，后32位为嵌入的IPv4地址。

1. **IPv4地址**：202.196.75.18

2. **将IPv4地址的每个部分转换为十六进制**：
   - 202 = CA
   - 196 = C4
   - 75  = 4B
   - 18  = 12

3. **组合十六进制表示**：
   - IPv4地址202.196.75.18转换为十六进制后为`CA.C4.4B.12`

4. **形成IPv6兼容地址**：
   - 将IPv4地址嵌入到IPv6的后32位，即`::CA:C4:4B:12`

IPv4地址202.196.75.18的IPv6兼容地址为`::CA:C4:4B:12`。





<img src="https://s2.loli.net/2024/06/29/9cPBiVMmI3nsSzR.png" alt="image-20240625215725335" style="zoom:50%;" />

## 6.若遵守CERNET IPv6试验床地址划分及分配方案，试求辽宁大学站点的前48位地址，东北地区编号为8，辽宁省编号为1，辽宁大学编号为3F6,如果信息学院所在的子网号为5，实验室的一个接口网卡的MAC地址为：00-11-5B-86-51-09，则其生成的IPv6地址如何表示？⭐



IPv6地址组成：由图表得到前48位 + 子网号16位 + 接口标识符64位

根据CERNET IPv6试验床地址划分及分配方案，以下是对辽宁大学信息学院实验室的IPv6地址生成过程的解析：

**Step1: 计算前48位地址的步骤**


1. **6Bone地址空间**: 0x3FFE
2. **CERNET分配的地址块**: 0x32
3. **正式使用的地址**: 0（0x00）
4. **东北地区的编号**: 8
5. **辽宁省的编号**: 1
6. **辽宁大学的编号**: 3F6

将这些信息组合成前48位地址：
```
3FFE:3208:13F6::/48
```

解释：
- 3FFE: 6Bone的地址空间前缀
- 32: CERNET分配的地址块
- 08: 东北地区
- 1: 辽宁省
- 3F6: 辽宁大学

2. **信息学院的子网号**

信息学院的子网号为5，转换为16进制表示为`0005`。将其添加到前48位地址中，形成64位前缀地址：
```
3FFE:3208:13F6:0005::/64
```

3. 生成EUI-64格式的**网络接口标识符**

1. **MAC地址**: 00-11-5B-86-51-09
2. **将MAC地址转换为EUI-64格式**：
   - 将MAC地址拆分为两部分：00-11-5B 和 86-51-09
   - 插入`FF:FE`到中间：00-11-5B-FF-FE-86-51-09
3. **翻转第7位**（从左边数的第一个字节的倒数第二位）：
   - 原字节：00（00000000）
   - 翻转第7位：02（00000010）
   - 新的MAC地址：02-11-5B-FF-FE-86-51-09
4. **将结果分组并写入IPv6地址**：
   - 02:11:5B:FF:FE:86:51:09

4. 组合完整的IPv6地址

将EUI-64格式的地址添加到64位前缀中，最终的IPv6地址是：
```
3FFE:3208:13F6:0005:0211:5BFF:FE86:5109
```

1. **前48位地址**：
   
   ```
   3FFE:3208:13F6::/48
   ```
2. **IPv6地址**：
   
   ```
   3FFE:3208:13F6:0005:0211:5BFF:FE86:5109
   ```



## 7.写出IPv4地址202.196.73.16的IPv6兼容地址和**映射地址**：





IPv4地址202.196.73.16可以转换为IPv6兼容地址和IPv6映射地址。以下是这两种地址的定义和计算过程。

1. IPv6兼容地址

这些地址用于将IPv4地址嵌入到IPv6地址中，使得IPv6节点能够与IPv4节点直接通信。

IPv6兼容地址用于表示**双栈节点**，即同时支持IPv4和IPv6的节点。这种地址结构**前96位为0，后32位为IPv4地址**。

计算IPv6兼容地址

- IPv4地址：202.196.73.16
- 将IPv4地址转换为十六进制：
  - 202 = CA
  - 196 = C4
  - 73  = 49
  - 16  = 10

IPv6兼容地址格式为`::/96` + IPv4地址部分：
```
::CA:C4:49:10
```

2. IPv6映射地址

这些地址用于**在IPv6网络中表示IPv4网络**，它们允许IPv6节点将IPv4网络视为IPv6网络的一部分。

IPv6映射地址用于在纯IPv6环境中表示一个IPv4节点。这种地址结构前80位为0，接下来16位为1（FFFF），后32位为IPv4地址。

计算IPv6映射地址

- IPv4地址：202.196.73.16
- 将IPv4地址转换为十六进制：
  - 202 = CA
  - 196 = C4
  - 73  = 49
  - 16  = 10

IPv6映射地址格式为`::FFFF:0:0/96` + IPv4地址部分：
```
::FFFF:CA:C4:49:10
```

- **IPv6兼容地址**：
  ```
  ::CA:C4:49:10
  ```
- **IPv6映射地址**：
  ```
  ::FFFF:CA:C4:49:10
  ```

这两种地址用于不同的场景，兼容地址用于IPv4/IPv6双栈节点，映射地址用于表示纯IPv6环境中的IPv4节点。



## 8.现截取了 3 个以太网帧 Frame#1-Frame#3，假设这些以太网帧通过了错误校验，用十六进制表示的帧内容如下：⭐

Frame#1Server→Client

```
00 80 C8 5A E3 88 00 60 2F 87 01 03 08 00 45 08
00 2C D1 22 40 00 3F 06 8A 27 8C 80 63 05 8C 80
64 74 00 14 02 66 AA a1 20 8D 00 00 00 00 60 02
40 00 5E 3C 00 00 02 04 05 B4
```

Frame#2Client→Server

```
00 60 2F 87 01 03 00 80 C8 5A E3 88 08 00 45 00
00 2C 81 0E 40 00 80 06 99 43 8C 80 64 74 8C 80
63 05 02 66 00 14 12 38 BB 3E AA A1 20 8E 60 12
22 38 C0 7C 00 00 02 04 05 b4
```

Frame#3Server→Client

```
00 80 c8 5a e3 88 00 60 2f 87 01 03 08 00 45 08
00 28 d1 23 40 00 3f 06 8a 2a 8c 80 63 05 8c 80
64 74 00 14 02 66 aa a1 19 8e 12 38 bb 3f 50 10
44 70 b6 01 00 00
```

这 3 个数据包主要用于建立一个 TCP 连接，根据协议的封装关系，以及各层数据包格式的结构，对这些数据包进行分析，回答如下问题:“
**(1) Client 端和 Server 端的以太网网卡 48 位地址是何值?**

**(2)Frame#1 帧中封装的 IP 分组的总长度、首部长度、IP 数据长度分别是多少?”**

**(3)Client 端和 Server 端的 32 位 IP 地址(用点分十进制格式表示)各是多少?"**

**(4)Frame#1 帧中封装的 IP 分组的生存时间值是多少?协议字段值是多少?IP 分组中封装的是**
**哪一个协议的数据?"**

**(5)Frame#1 中封装的 IP 分组的首部是否含有“选项”字段?如何判断?”**

**(6)写出 TCP 连接的套接字对，用十六进制形式表示**

**(7)使用这个 TCP 连接的 Server 端和 Client 端，其各自“序列号”分别为何值?**

![img](https://s2.loli.net/2024/06/26/bJEa2qCO9jV5r86.jpg)

为了详细分析这三个以太网帧，我们需要按照以下步骤逐一解析每个帧的内容。我们将通过解码帧头和IP头来回答各个问题。

**Frame#1 分析**

为16进制  每两位代表一字节，前14位是MAC帧首部，后4位是FCS帧检测，中间是IP数据报

```
00 80 C8 5A E3 88 00 60 2F 87 01 03 08 00 45 08
00 2C D1 22 40 00 3F 06 8A 27 8C 80 63 05 8C 80
64 74 00 14 02 66 AA A1 20 8D 00 00 00 00 60 02
40 00 5E 3C 00 00 02 04 05 B4
```

**(1) Client 端和 Server 端的以太网网卡 48 位地址是何值?**

以太网帧头格式：
- 目标MAC地址：6字节
- 源MAC地址：6字节
- 以太网类型：2字节

Frame#1 的以太网帧头：
- 目标MAC地址（Server）：00 80 C8 5A E3 88
- 源MAC地址（Client）：00 60 2F 87 01 03

因此：
- Client 端 MAC 地址：00:60:2F:87:01:03
- Server 端 MAC 地址：00:80:C8:5A:E3:88

关于类型：

`08 00`: IPv4协议

`86 DD`: IPv6协议

**(2) Frame#1 帧中封装的 IP 分组的总长度、首部长度、IP 数据长度分别是多少?**

<img src="https://s2.loli.net/2024/06/26/7DJrfbGRV1KSx3e.jpg" alt="img" style="zoom:50%;" />

IP头格式（20字节）：

- 版本和首部长度：1字节
- 服务类型：1字节
- 总长度：2字节
- 标识：2字节
- 标志和片偏移：2字节
- 生存时间：1字节
- 协议：1字节
- 首部校验和：2字节
- 源IP地址：4字节
- 目标IP地址：4字节

Frame#1 的 IP 头部分：
```
45 08 00 2C D1 22 40 00 3F 06 8A 27 8C 80 63 05 8C 80 64 74
```

- 版本和首部长度：45
  - 版本：4（IPv4）
  - 首部长度：5 * 4 = 20字节  **（在IPv4协议中，首部长度的单位是4字节，所以乘4）**
- 总长度：00 2C = 44字节  （直接转为10进制，得到对应长度）
- IP数据长度：总长度 - 首部长度 = 44 - 20 = 24字节

因此：
- 总长度：44字节
- 首部长度：20字节
- IP数据长度：24字节

(3) Client 端和 Server 端的 32 位 IP 地址(用点分十进制格式表示)各是多少?

Frame#1 的源IP地址和目标IP地址：
- 源IP地址：8C 80 63 05
- 目的IP地址：8C 80 64 74

转换为点分十进制格式：
- 目的IP地址：140.128.99.5
- 源IP地址：140.128.100.116

因此：
-  Client端 IP 地址：140.128.99.5
- Server端 IP 地址：140.128.100.116

**(4) Frame#1 帧中封装的 IP 分组的生存时间值是多少?协议字段值是多少?IP 分组中封装的是哪一个协议的数据?**

Frame#1 的生存时间和协议字段：
- 生存时间：3F
- 协议：06

生存时间值（TTL）：63（0x3F）
协议字段值：6（TCP）

```
01 - ICMP (Internet Control Message Protocol)
06 - TCP (Transmission Control Protocol)
11 - UDP (User Datagram Protocol)
```

因此，IP分组中封装的是TCP协议的数据。

**(5) Frame#1 中封装的 IP 分组的首部是否含有“选项”字段?如何判断?**

选项字段属于IP分组的首部，此**IP分组的首部位20B，不含有选项字段**。

首部长度字段的值为5，表示没有“选项”字段。IPv4的首部长度单位是4字节，5表示首部长度为20字节（5 * 4 = 20字节），这是标准的IPv4头部长度，所以没有包含选项字段。

**(6) 写出 TCP 连接的套接字对，用十六进制形式表示**

**TCP格式**

TCP（传输控制协议）头部格式包含以下字段，总长度为20到60字节（以32位字为单位）。各字段详细说明如下：

1. **源端口号（Source Port）**：16位，标识发送端的应用程序端口号。
2. **目的端口号（Destination Port）**：16位，标识接收端的应用程序端口号。
3. **序列号（Sequence Number）**：32位，用于标识从发送端向接收端发送的数据字节流的顺序。
4. **确认号（Acknowledgment Number）**：32位，用于确认接收到的数据。只有当ACK标志为1时，该字段才有效。
5. **数据偏移（Data Offset）**：4位，表示TCP头部的长度，以32位字（4字节）为单位。
6. **保留字段（Reserved）**：3位，保留供将来使用，必须置0。
7. **控制位（Flags/Control Bits）**：9位，包括以下几个标志位：
   - **NS（Nonce Sum）**：1位，ECN-nonce（显式拥塞通知）。
   - **CWR（Congestion Window Reduced）**：1位，标志发送方已经接收到一个具有ECE标志的数据包。
   - **ECE（ECN-Echo）**：1位，指示发送方在接收到的TCP报文段中设置了ECN（显式拥塞通知）。
   - **URG（Urgent）**：1位，表明紧急指针字段有效。
   - **ACK（Acknowledgment）**：1位，表明确认号字段有效。
   - **PSH（Push）**：1位，请求接收方立即将数据推送到应用层。
   - **RST（Reset）**：1位，重新建立连接。
   - **SYN（Synchronize）**：1位，表示建立连接。
   - **FIN（Finish）**：1位，表示释放连接。
8. **窗口大小（Window Size）**：16位，表示接收方的接受窗口大小，用于流量控制。
9. **校验和（Checksum）**：16位，用于检验头部和数据是否有误。
10. **紧急指针（Urgent Pointer）**：16位，指示紧急数据的末尾位置，只有当URG标志为1时有效。
11. **选项（Options）**：可变长，最多40字节，用于指定TCP的附加功能。
12. **填充（Padding）**：用于填充，使整个TCP头部长度为32位的整数倍。

以下是TCP头部的示意图：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Data  | Reser-|       Flags         |       Window Size       |
|Offset | ved   |       9 bits        |                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Checksum            |    Urgent Pointer                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Options (if any)                                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Padding (if any)                                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```



套接字对：就是地址：端口号

Frame#1 的TCP头：
```
00 14 02 66 AA A1 20 8D 00 00 00 00 60 02 40 00 5E 3C 00 00 02 04 05 B4
```

源端口：00 14 = 20
目标端口：02 66 = 614

因此，TCP连接的套接字对是：**(地址：端口号) 地址前面已经求出**
- 源：140.128.99.5:20
- 目标：140.128.100.116:614

用十六进制表示：
- 源：8C 80 63 05:0014
- 目标：8C 80 64 74:0266

**(7) 使用这个 TCP 连接的 Server 端和 Client 端，其各自“序列号”分别为何值?**

Frame#1 的TCP头中的序列号：
- 序列号：AA A1 20 8D

因此：
- Server端序列号：AA A1 20 8D
- Client端序列号：无（从帧中解析的内容来看，Frame#1是Server到Client的帧，没有Client端的序列号）

**Frame#2 分析**

```
00 60 2F 87 01 03 00 80 C8 5A E3 88 08 00 45 00
00 2C 81 0E 40 00 80 06 99 43 8C 80 64 74 8C 80
63 05 02 66 00 14 12 38 BB 3E AA A1 20 8E 60 12
22 38 C0 7C 00 00 02 04 05 b4
```

**(1) Client 端和 Server 端的以太网网卡 48 位地址是何值?**

以太网帧头：
- 目标MAC地址（Server）：00 60 2F 87 01 03
- 源MAC地址（Client）：00 80 C8 5A E3 88

**(3) Client 端和 Server 端的 32 位 IP 地址(用点分十进制格式表示)各是多少?**

Frame#2 的源IP地址和目标IP地址：
- 源IP地址：8C 80 64 74
- 目标IP地址：8C 80 63 05

转换为点分十进制格式：
- 源IP地址：140.128.100.116
- 目标IP地址：140.128.99.5

**Frame#3 分析**

```
00 80 c8 5a e3 88 00 60 2f 87 01 03 08 00 45 08
00 28 d1 23 40 00 3f 06 8a 2a 8c 80 63 05 8c 80
64 74 00 14 02 66 aa a1 19 8e 12 38 bb 3f 50 10
44 70 b6 01 00 00
```

**(1) Client 端和 Server 端的以太网网卡 48 位地址是何值?**

以太网帧头：
- 目标MAC地址（Server）：00 80 C8 5A E3 88
- 源MAC地址（Client）：00 60 2F 87 01 03

**(3) Client 端和 Server 端的 32 位 IP 地址(用点分十进制格式表示)各是多少?**

Frame#3 的源IP地址和目标IP地址：
- 源IP地址：8C 80 63 05
- 目标IP地址：8C 80 64 74

转换为点分十进制格式：
- 源IP地址：140.128.99.5
- 目标IP地址：140.128.100.116

总结

1. **Client 端和 Server 端的以太网网卡 48 位地址**：
   - Client 端：00:60:2F:87:01:03
   - Server 端：00:80:C8:5A:E3:88

2. **Frame#1 帧中封装的 IP 分组的总长度、首部长度、IP 数据长度**：
   - 总长度：44字节
   - 首部长度：20字节
   - IP数据长度：24字节

3. **Client 端和 Server 端的 32 位 IP 地址**：
   - Client 端：140.128.99.5
   - Server 端：140.128.100.116

4. **Frame#1 帧中封装的 IP 分组的生存时间值和协议字段值**：
   - 生存时间（TTL）：64
   - 协议字段值：6（TCP）

5. **Frame#1 中封装的 IP 分组的首部是否含有“选项”字段**：
   - 不含有选项字段

6. **TCP 连接的套接字对**：
   - 源：8C 80 63 05:0014
   - 目标：8C 80 64 74:0266

7. **Server 端和 Client 端的序列号**：
   - Server端序列号：AA A1 20 8D



## 9.主机A向主机B连续发送了两个TCP报文段，其序号分别为80和120。试问：

（1）第一个报文段携带了【填空1】个字节的数据

（2）主机B收到第一个报文段后发回的确认中的确认号应当是【填空2】。

（3）如果主机B收到第二个报文段后发回的确认中的确认号是180，试问A发送的第二个报文段中的数据有【填空3字节】。

（4）如果A发送的第一个报文段丢失了，但第二个报文段到达了B。B在第二个报文段到达后向A发送确认。试问这个确认号应为【填空4】。







TCP（传输控制协议）是一种面向连接的、可靠的传输层协议。TCP通过序号和确认机制来保证数据包的有序、可靠传输。

- **序号（Sequence Number）：** 表示数据流中第一个字节的位置。
- **确认号（Acknowledgment Number）：** 表示接收方期望接收到的下一个字节的位置。

TCP的序号和确认号机制确保了数据包能够按照正确的顺序到达，并且发送方可以知道哪些数据已经被成功接收。

问题解析

（1）第一个报文段携带了【填空1】个字节的数据

**问题：** 主机A向主机B连续发送了两个TCP报文段，其序号分别为80和120。第一个报文段携带了多少个字节的数据？

**解析：**

- 第一个报文段的序号是80。
- 第二个报文段的序号是120。
- 序号是基于字节的，因此两个报文段之间的差值就是第一个报文段的数据长度。

计算方法：
\[ \text{数据长度} = 120 - 80 = 40 \]

因此，填空1的答案是40字节。

（2）主机B收到第一个报文段后发回的确认中的确认号应当是【填空2】

**问题：** 主机B收到第一个报文段后发回的确认中的确认号应当是多少？

**解析：**
- 主机B收到第一个报文段，其序号是80，携带了40字节的数据。
- 确认号表示接收方期望接收的下一个字节的位置。

计算方法：
\[ \text{确认号} = 80 + 40 = 120 \]

因此，填空2的答案是120。

（3）如果主机B收到第二个报文段后发回的确认中的确认号是180，试问A发送的第二个报文段中的数据有【填空3】字节

**问题：** 如果主机B收到第二个报文段后发回的确认号是180，A发送的第二个报文段中的数据有多少字节？

**解析：**
- 第二个报文段的序号是120。
- 主机B发回的确认号是180，这表示B已经收到了序号从120到179的数据，并期望收到序号180的数据。

计算方法：
\[ \text{数据长度} = 180 - 120 = 60 \]

因此，填空3的答案是60字节。

（4）如果A发送的第一个报文段丢失了，但第二个报文段到达了B。B在第二个报文段到达后向A发送确认。试问这个确认号应为【填空4】

**问题：** 如果A发送的第一个报文段丢失了，但第二个报文段到达了B，B在第二个报文段到达后向A发送确认。这个确认号应为多少？

**解析：**
- 第一个报文段的序号是80，携带40字节数据，但丢失了。
- 第二个报文段的序号是120，携带60字节数据，但由于第一个报文段丢失，B无法接收和处理第二个报文段的数据。
- 按照TCP的机制，B会发送一个期望接收的下一个字节的位置，这个位置是第一个报文段的开始位置，因为B还没有收到任何数据。

因此，B期望接收的数据位置仍然是80。

所以，填空4的答案是80。



## 10.一个网络中，设定的P地址范围是172.88.32.1~172.88.63.254，试确定其合适的子网掩码【填空】

255.255.224.0



## 11.给定的IP地址为192.55.12.120，子网掩码为255.255.255.240，那么网络地址和主机号分别是「填空1]【填空2]：直接广播地址是［填空3]





要回答这个问题，我们需要理解以下几个网络基础概念：

1. **IP地址（Internet Protocol Address）：** 是分配给计算机设备的唯一标识，用于在网络中进行通信。
2. **子网掩码（Subnet Mask）：** 是用于划分IP地址的网络部分和主机部分的一个32位掩码。
3. **网络地址（Network Address）：** 是子网的第一个地址，用于标识子网。
4. **主机号（Host Number）：** 是IP地址中用于标识网络中主机的部分。
5. **直接广播地址（Direct Broadcast Address）：** 是网络中所有主机的目标地址，用于发送广播消息。

具体解答

**给定：**

- IP地址：192.55.12.120
- 子网掩码：255.255.255.240

（1）计算网络地址和主机号

**子网掩码的二进制表示：**
```
255.255.255.240 = 11111111.11111111.11111111.11110000
```

**IP地址的二进制表示：**

```
192.55.12.120 = 11000000.00110111.00001100.01111000
```

**计算网络地址：**
网络地址是通过将IP地址与子网掩码进行逐位“与”（AND）运算得到的。

```
11000000.00110111.00001100.01111000 (IP地址)
AND
11111111.11111111.11111111.11110000 (子网掩码)
-----------------------------------
11000000.00110111.00001100.01110000 (网络地址)
```

网络地址的二进制表示转换为十进制：
```
11000000.00110111.00001100.01110000 = 192.55.12.112
```

**计算主机号：**
主机号是IP地址中主机部分的二进制值，即：
```
11000000.00110111.00001100.01111000 (IP地址)
AND
00000000.00000000.00000000.00001111 (反掩码)
-----------------------------------
00000000.00000000.00000000.00001000 (主机号)
```

主机号的二进制表示转换为十进制：
```
00000000.00000000.00000000.00001000 = 8
```

所以：
- 网络地址是：192.55.12.112
- 主机号是：8

（2）计算直接广播地址

直接广播地址是将**网络地址的主机号部分**全部置为1。

**直接广播地址的二进制表示：**

```
11000000.00110111.00001100.01110000 (网络地址)
OR
00000000.00000000.00000000.00001111 (反掩码)
-----------------------------------
11000000.00110111.00001100.01111111 (直接广播地址)
```

直接广播地址的二进制表示转换为十进制：
```
11000000.00110111.00001100.01111111 = 192.55.12.127
```

所以：
- 直接广播地址是：192.55.12.127

最终答案

- 网络地址是：192.55.12.112
- 主机号是：8
- 直接广播地址是：192.55.12.127

考察的知识点

1. **IP地址和子网掩码的基本概念和二进制表示：** 了解如何将IP地址和子网掩码转换为二进制形式。
2. **网络地址计算：** 通过IP地址和子网掩码的逐位“与”运算来计算网络地址。
3. **主机号计算：** 通过IP地址和子网掩码的逐位“与”运算来分离主机号部分。
4. **直接广播地址计算：** 了解如何通过网络地址和反掩码的逐位“或”运算来计算直接广播地址。





## 12.假设一个有效载荷为4349B的原IPv6分组·需要从结点A传送到结点B。已经探测到从A到B的路由MTU，即PMTU为1500B。所以源结点A必须对这个IPv6分组进行分片处理。请间需要分几个分片？⭐











要解决这个问题，我们需要了解IPv6分片的基本原理和相关的计算方法。

背景知识

**IPv6分片：** IPv6使用**分片扩展头**来实现分片。分片扩展头包含以下字段：

- **Fragment Offset（分片偏移量）：** 指定当前分片相对于原始数据包的偏移量，以8字节为单位。
- **M标志位（More Fragment flag）：** 表示是否有更多分片，如果是最后一个分片则M标志位为0，否则为1。
- **Payload Length（有效载荷长度）：** 分片数据部分的长度，不包括IPv6头和分片扩展头的长度。

**MTU（Maximum Transmission Unit）：** 路由器能传输的最大数据包大小，包括IPv6头和任何扩展头。

在此问题中，给定的MTU为1500字节，因此IPv6头和分片扩展头的开销将减少有效载荷的大小。IPv6头为40字节，**分片扩展头为8字节**，所以每个分片可以携带的最大数据为：

有效载荷=MTU−IPv6头−分片扩展头=1500−40−8=1452字节

由于分片偏移量以8字节为单位，因此每个分片的**有效载荷长度必须是8的倍数**。

分片计算

1. **确定每个分片的有效载荷长度：**
   - 每个分片的有效载荷长度为1452字节。
   - 但是1452不是8的倍数，所以我们需要取8的最大倍数。
   - 因此，每个分片的有效载荷长度为1448字节（1452-4）。取小

2. **计算所需的分片数：**
   - 原始有效载荷为4349字节。
   - 每个分片的有效载荷为1448字节。
   - 分片数计算：
     ![image-20240626152321953](https://s2.loli.net/2024/06/26/yAJ7ELifCezrTnR.png)

3. **各分片的详细信息：**
   - 第1-3个分片的有效载荷长度为1448字节。
   - 最后一个分片的有效载荷长度为4349 - 3 * 1448 = 5字节。
   - 各分片的**分片偏移量**为前一个分片的偏移量加上有效载荷长度除以8的结果。

表格结果

| 分片编号 | 有效载荷长度（字节） | M标志位 | 分片偏移量 |
| -------- | -------------------- | ------- | ---------- |
| 1        | 1448                 | 1       | 0          |
| 2        | 1448                 | 1       | 181        |
| 3        | 1448                 | 1       | 362        |
| 4        | 5                    | 0       | 543        |

详细计算过程

1. **第1个分片：**
   - 有效载荷长度：1448字节
   - M标志位：1（还有后续分片）
   - 分片偏移量：0

2. **第2个分片：**
   - 有效载荷长度：1448字节
   - M标志位：1（还有后续分片）
   - 分片偏移量：\((0 + 1448) / 8 = 181\)

3. **第3个分片：**
   - 有效载荷长度：1448字节
   - M标志位：1（还有后续分片）
   - 分片偏移量：\((181 \times 8 + 1448) / 8 = 362\)

4. **第4个分片：**
   - 有效载荷长度：5字节
   - M标志位：0（没有后续分片）
   - 分片偏移量：\((362 \times 8 + 1448) / 8 = 543\)

最终结果

| 分片编号 | 有效载荷长度（字节） | M标志位 | 分片偏移量 |
| -------- | -------------------- | ------- | ---------- |
| 1        | 1448                 | 1       | 0          |
| 2        | 1448                 | 1       | 181        |
| 3        | 1448                 | 1       | 362        |
| 4        | 5                    | 0       | 543        |

考察的知识点

1. **IPv6头和扩展头的结构和功能：** 特别是分片扩展头的格式。
2. **MTU的概念和作用：** 了解MTU限制对数据传输的影响。
3. **分片的计算方法：** 如何根据MTU和有效载荷长度进行分片，并正确设置分片偏移量和M标志位。
4. **数据包处理和传输：** 数据包在网络中传输时如何处理分片和重组。



## 13.、若一个主机网卡接口的MAC地址为F8-32-E4-9A-7E-86，试写出该接口相对应的EUI-64格式的网络接口标识符【填空1】。假设该主机连接在前缀为3FFE：3002：1100：：/48，并且在子网地址为10（十进制数）的网络上，请写出该主机接口的IPv6可聚合全局单播地址【填空2】，以及其所对应的被请求节点多播地址【填空3】。⭐













1. 计算EUI-64格式的网络接口标识符

EUI-64格式的网络接口标识符是**基于MAC地址生成**的，需要以下几个步骤：

1. **将MAC地址分为两个24位的部分：**
   - 原始MAC地址：F8-32-E4-9A-7E-86
   - 前24位：F8-32-E4
   - 后24位：9A-7E-86

2. **在中间插入16位的值FFFE：**
   - 前24位：F8-32-E4
   - 插入16位：FFFE
   - 后24位：9A-7E-86

   组合起来就是：F8-32-E4-FF-FE-9A-7E-86

3. **将MAC地址的第7位（全局/本地位）翻转：**
   - 原始MAC地址的第一个字节是F8，二进制表示为：1111 1000
   - 第7位是1（从左数），翻转后为0
   - 得到的第一个字节是FA（1111 1010）

所以，EUI-64格式的**网络接口标识符**是：FA-32-E4-FF-FE-9A-7E-86

**填空1：FA32:E4FF:FE9A:7E86**

2. 生成IPv6可聚合全局单播地址

给定：
- 网络前缀：3FFE:3002:1100::/48
- 子网地址：10（十进制），即0A（十六进制）

IPv6地址格式：
![image-20240626153357310](https://s2.loli.net/2024/06/26/CE4dl8DsS2bpfJa.png)

将上述信息组合起来：
- 前缀：3FFE:3002:1100
- 子网标识符：000A
- 接口标识符：FA32:E4FF:FE9A:7E86

组合后：
\[ 3FFE:3002:1100:000A:FA32:E4FF:FE9A:7E86 \]

**填空2：3FFE:3002:1100:000A:FA32:E4FF:FE9A:7E86**

3. 计算被请求节点多播地址

被请求节点多播地址格式为：
**\[ FF02::1:FFXX:XXXX \]**
其中，XX:XXXX是接口标识符的最后24位。

接口标识符：FA32:E4FF:FE9A:7E86
最后24位：9A:7E:86

被请求节点多播地址：
\[ FF02::1:FF9A:7E86 \]

**填空3：FF02::1:FF9A:7E86**

最终答案

1. EUI-64格式的网络接口标识符：
   **FA32:E4FF:FE9A:7E86**

2. IPv6可聚合全局单播地址：
   **3FFE:3002:1100:000A:FA32:E4FF:FE9A:7E86**

3. 被请求节点多播地址：
   **FF02::1:FF9A:7E86**

考察的知识点

1. **MAC地址与EUI-64格式转换：** 了解如何从MAC地址生成EUI-64格式的网络接口标识符。
2. **IPv6地址结构与生成：** 了解IPv6地址的前缀、子网标识符和接口标识符的构成及其组合。
3. **多播地址的构成与计算：** 了解被请求节点多播地址的格式及其生成方法。



## 14.若IPv6分组由基本首部和TCP报文段组成，假设TCP报文段的总长度是256B。试表示这个分组，并给出所能确定字段的值。















IPv6分组由基本首部（IPv6基本头）和数据部分（例如TCP报文段）组成。以下是IPv6基本头的结构以及我们需要确定的字段值。

IPv6基本头结构

IPv6基本头由以下字段组成，总长度为40字节：

1. **版本（Version）：** 4位，表示IP版本号，IPv6的值为6。
2. **流量类别（Traffic Class）：** 8位，用于区分不同的流量类别。
3. **流标签（Flow Label）：** 20位，用于标识数据流。
4. **有效载荷长度（Payload Length）：** 16位，表示有效载荷（不包括IPv6头）的长度。
5. **下一个头（Next Header）：** 8位，表示紧跟在IPv6头之后的头部类型，TCP协议的值为6。
6. **跳限（Hop Limit）：** 8位，表示数据包可以经过的最大跳数。
7. **源地址（Source Address）：** 128位，表示发送端的IPv6地址。
8. **目的地址（Destination Address）：** 128位，表示接收端的IPv6地址。

假设和给定条件

- **TCP报文段的总长度是256B。**
- **IPv6基本头的长度是40B。**

需要确定的字段值

1. **版本（Version）：** 6
2. **流量类别（Traffic Class）：** 0（假设默认值）
3. **流标签（Flow Label）：** 0（假设默认值）
4. **有效载荷长度（Payload Length）：** 256（TCP报文段长度） + 0（假设没有其他扩展头） = 256
5. **下一个头（Next Header）：** 6（TCP协议）
6. **跳限（Hop Limit）：** 64（常见默认值，但具体值依赖于实现）
7. **源地址（Source Address）：** 例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334（示例地址）
8. **目的地址（Destination Address）：** 例如，2001:0db8:85a3:0000:0000:8a2e:0370:1234（示例地址）

IPv6分组表示

```plaintext
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|版本(0.5字节) |   流量类别(1字节)   |       流标签(2.5字节)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   负载长度(2字节)        |  下一个头部(1字节)  | 跳数限制(1字节) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                                                               |
|                          源地址(16字节)                        |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                                                               |
|                         目的地址(16字节)                       |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

确定字段的值

1. **版本（Version）：** 0110（二进制） -> 6
2. **流量类别（Traffic Class）：** 00000000（二进制） -> 0
3. **流标签（Flow Label）：** 0000 0000 0000 0000 0000（二进制） -> 0
4. **有效载荷长度（Payload Length）：** 0000 0001 0000 0000（二进制） -> 256
5. **下一个头（Next Header）：** 0000 0110（二进制） -> 6
6. **跳限（Hop Limit）：** 0100 0000（二进制） -> 64
7. **源地址（Source Address）：** 2001:db8:85a3:0:0:8a2e:370:7334（示例）
8. **目的地址（Destination Address）：** 2001:db8:85a3:0:0:8a2e:370:1234（示例）

完整的IPv6分组表示

```
|版本|  流量类别  |           流标签                |
|0110| 0000 0000  |      0000 0000 0000 0000 0000   |
|     有效载荷长度    |  下一个头  |  跳限    |
|0000 0001 0000 0000 | 0000 0110 | 0100 0000 |
|          源地址（128位）                    |
|  2001:0db8:85a3:0000:0000:8a2e:0370:7334  |
|       目的地址（128位）                     |
|  2001:0db8:85a3:0000:0000:8a2e:0370:1234  |
|          TCP有效载荷（256B）                |
```

结论

IPv6基本头由以上字段组成，其中有些字段是固定值或默认值（如版本、流量类别、流标签等），有些字段（如源地址、目的地址、有效载荷长度、下一个头、跳限等）需要根据具体情况来填写。在本例中，有效载荷长度为256，表示TCP报文段的长度，下一个头为6表示TCP协议，跳限为64，源地址和目的地址为示例地址。



## 15.如果网卡的MAC地址为00-11-5B-86-51-09，则按上述式映射成的64位网络接口标识号为（用十六进制数表示）

0211:5BFF:FE86:5109



## 16.试写出对扩展首部追加10B的padN填充选项，其格式何如？

在IPv6中，扩展首部的填充选项（PadN）用于确保特定字段在适当的**边界对齐**。PadN选项可以填充任意数量的字节。PadN选项的格式如下：

1. **下一个头（Next Header）：** 指示下一个扩展首部或上层协议的类型。
2. **头部扩展长度（Header Extension Length）：** 表示扩展首部的长度。
3. **PadN选项类型（Option Type）：** 表示这是一个PadN选项。
4. **PadN选项长度（Option Length）：** 表示填充字节的数量。
5. **填充字节（Padding）：** 实际的填充字节，用于对齐。

示例：对扩展首部追加10字节的PadN填充选项

假设我们有一个IPv6扩展首部，需要在其中添加一个长度为10字节的PadN选项。PadN选项的格式如下：

1. **PadN选项类型（Option Type）：** 1字节，固定值为1。
2. **PadN选项长度（Option Length）：** 1字节，表示填充字节的数量。
3. **填充字节（Padding）：** 实际的填充字节。

PadN选项格式

```plaintext
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Option Type  | Option Length |         Padding               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      1        |       10      | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

各字段解释

- **Option Type（选项类型）：** 0x01
- **Option Length（选项长度）：** 0x0A（表示填充10字节）
- **Padding（填充）：** 10个0字节

填充选项示例

```plaintext
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      1        |       10      | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 0 | 0                                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

总结

上述格式是PadN选项的具体格式，其中Option Type为1，Option Length为10，后面紧跟着10个填充的0字节。这个选项可以插入到IPv6扩展首部中，以确保特定字段在适当的边界对齐。



## 17

（1）请写出IPv6单播地址3FFE:3201:3001:1:020D:87FF:FE04:6F30所对应的被请求结点多播地址

（2）若某主机地址为562E​：1234:2341:CDAB:：1123接口标识符为64位，试确定该主机所连接的子网地址

**（1）IPv6单播地址对应的被请求节点多播地址**

被请求节点多播地址是用来在IPv6网络中通过多播方式查询某个单播地址的邻居的。这种多播地址的格式为：`FF02::1:FFXX:XXXX`，其中`XX:XXXX`为单播地址的最后24位。

给定的单播地址

单播地址：3FFE:3201:3001:1:020D:87FF:FE04:6F30

**提取单播地址的最后24位**

单播地址的最后24位是：04:6F30

**构造被请求节点多播地址**

被请求节点多播地址格式：`FF02::1:FFXX:XXXX`

将最后24位04:6F30填入多播地址：

被请求节点多播地址：`FF02::1:FF04:6F30`

**（2）确定主机所连接的子网地址**

给定的子网地址为：`562E:1234:2341:CDAB::1123`，接口标识符为64位。

**子网地址结构**

IPv6子网地址由**前64位的网络前缀和后64位的接口标识符**组成。要确定主机所连接的子网地址，需要将接口标识符部分置为全零。

**提取网络前缀**

前64位的网络前缀是：`562E:1234:2341:CDAB`

**构造子网地址**

将接口标识符部分置为全零：

子网地址：`562E:1234:2341:CDAB::`

总结

1. **IPv6单播地址3FFE:3201:3001:1:020D:87FF:FE04:6F30对应的被请求节点多播地址是：**

   `FF02::1:FF04:6F30`

2. **某主机子网地址为`562E:1234:2341:CDAB::1123`，接口标识符为64位，主机所连接的子网地址是：**

   `562E:1234:2341:CDAB::`



## 18.假设一个有效载荷为2902字节的原IPv6分组，没有扩展首部。需要通过以太网MTU=(1500B）传送。必须对该IPv6分组进行分片，分多少分片？







1. **计算初始分组的总大小**：
   - 有效载荷：2902字节
   - IPv6固定首部：40字节
   - 总大小：2902字节 + 40字节 = 2942字节

2. **计算每个分片的最大有效载荷大小**：
   - 每个分片的最大大小：1500字节（以太网MTU）
   - 分片首部：8字节
   - 每个分片的最大有效载荷：1500字节 - 40字节（IPv6固定首部） - 8字节（分片首部） = 1452字节

3. **调整为8字节的倍数**：
   - 每个分片的最大有效载荷：1448字节（最接近的8字节倍数） 最大有效载荷应该为8B的整数倍

4. **计算需要的分片数**：
   - 第一个分片的有效载荷：1448字节
   - 第二个分片的有效载荷：1448字节
   - 剩余的有效载荷：2902字节 - 1448字节 - 1448字节 = 6字节

因此，实际上需要三个分片：
1. 第一个分片：1448字节有效载荷 + 40字节（固定首部）+ 8字节（分片首部）= 1496字节
2. 第二个分片：1448字节有效载荷 + 40字节（固定首部）+ 8字节（分片首部）= 1496字节
3. 第三个分片：6字节有效载荷 + 40字节（固定首部）+ 8字节（分片首部）= 54字节

这样，每个分片的有效载荷都是8字节的倍数，并且总大小也符合以太网MTU的要求。

所以，**需要3个分片**来传输这个IPv6分组。



## 19.FEC0::1:0250:3EFF:FEE4:4B01的被请求结点的多播地址是

FF02::1:FFE4:4B01



## 20.设IP数据报使用固定首部，其各字段的具体数值如图所示，试用十六进制数填写首部检验和【填空1]

 ![Snipaste_2024-06-26_16-33-36](https://s2.loli.net/2024/06/26/nAwPQWjGzgkDxKC.jpg)







为了计算IP数据报的首部检验和，需要将各字段的值转换为16位的十六进制数，然后按位相加，最后取反得到检验和。下面是具体步骤：

1. **把各字段的值转换为十六进制表示**

1. **版本(Version)和头部长度(IHL)**：
   - 版本：4
   - 头部长度：5
   - 合并：45 (因为版本占4位，头部长度占4位)

2. **区分服务(DS)和ECN**：
   - DS：0
   - ECN：0
   - 合并：00

3. **总长度(Total Length)**：
   - 总长度：28
   - 转换为十六进制：001C

4. **标识(Identification)**：
   - 标识：1
   - 转换为十六进制：0001

5. **标志(Flags)和片偏移(Fragment Offset)**：
   - 标志：0
   - 片偏移：0
   - 合并：0000

6. **生存时间(TTL)**：
   - TTL：4
   - 转换为十六进制：04

7. **协议(Protocol)**：
   - 协议：17
   - 转换为十六进制：11

8. **源地址(Source Address)**：
   - 10.12.14.5
   - 转换为十六进制：0A0C0E05

9. **目的地址(Destination Address)**：
   - 12.6.7.9
   - 转换为十六进制：0C060709

2. **按顺序写出各字段的十六进制表示**  检验和部分先置为0000

```
45 00 00 1C 00 01 00 00 04 11 0000 0A0C0E05 0C060709
```

3. **按16位（两个字节）分组**

```
4500
001C
0001
0000
0411
0000
0A0C
0E05
0C06
0709
```

**4. 计算各组的和**

```
4500 + 001C + 0001 + 0000 + 0411 + 0000 + 0A0C + 0E05 + 0C06 + 0709
```

逐项相加：
```
4500 + 001C = 451C
451C + 0001 = 451D
451D + 0000 = 451D
451D + 0411 = 493E
493E + 0000 = 493E
493E + 0A0C = 533A
533A + 0E05 = 613F
613F + 0C06 = 6D45
6D45 + 0709 = 745E
```

5. **检查和处理进位**

先查看和是否有进位，即如果有高于16位的结果：
```
745E
```
没有需要处理的进位。

**6. 取反得到检验和**

```
~745E = 8BA1
```

所以，首部检验和是 **8BA1**。

因此，填空1应填入 **8BA1**。



## 21.某大学获得6Bone地址是3FFE：3205:3001：:/48，结点所在的链路子网的前缀为3FFE：3205:3001:1:：/64。如果网卡的MAC地址为00-0D-87-04-6F-30，那么当该结点启动时将自动从IPv6路由器获得网络地址，并生成自己的IPv6。该IPv6地址是什么？⭐









这道题和第六题的不同点在于：

给出了子网的前缀，不需要我们来拼凑，6Bone为一个大范围的地址，链路子网是其中的一个子网。

生成基于MAC地址的IPv6地址涉及以下几个步骤和知识点：

**步骤详解**

1. **拆分MAC地址**
   - 给定的MAC地址：`00-0D-87-04-6F-30`
   - 将其拆分为两部分：
     ```
     前3个字节：00-0D-87
     后3个字节：04-6F-30
     ```

2. **插入固定值FFFE**
   - 根据EUI-64标准，在MAC地址的中间插入固定值FFFE：
     ```
     00-0D-87-FF-FE-04-6F-30
     ```

3. **修改第7位**
   - 修改MAC地址的第一个字节的第7位（从左数），即将第一个字节的第2个最低有效位（LSB）翻转。
   - 00的二进制表示是：`00000000`
   - 将第7位翻转（从0变为1）：`00000010`
   - 结果为：`02`
   - 修改后的EUI-64地址为：
     ```
     02-0D-87-FF-FE-04-6F-30
     ```

4. **构建IPv6地址**
   - 将链路子网前缀 `3FFE:3205:3001:1::/64` 与 EUI-64地址拼接在一起：
     ```
     3FFE:3205:3001:1:020D:87FF:FE04:6F30
     ```

知识点考察

1. **IPv6地址结构**
   - IPv6地址长度为128位，通常表示为八组16位的十六进制数，每组之间用冒号分隔。
   - IPv6地址可以分为网络前缀和接口标识符（IID）。网络前缀标识网络，接口标识符标识网络中的具体接口。

2. **EUI-64格式**
   - EUI-64格式用于根据MAC地址生成64位的接口标识符。
   - 该格式将48位的MAC地址转换为64位的接口标识符，通过在MAC地址的中间插入`FFFE`。
   - 同时，需翻转MAC地址的第7位以符合IPv6规范。

3. **IPv6无状态自动配置（SLAAC）**
   - 当IPv6设备连接到网络时，它可以通过无状态地址自动配置（SLAAC）机制自动生成其IPv6地址。
   - 设备会从本地路由器获取网络前缀，然后使用EUI-64方法生成唯一的接口标识符。
   - 最终的IPv6地址是网络前缀与EUI-64生成的接口标识符的组合。

4. **MAC地址和EUI-64**
   - MAC地址通常为48位，用于在网络中唯一标识每个设备。
   - EUI-64是基于MAC地址生成64位标识符的方法，适用于IPv6的接口标识符。

通过上述步骤和知识点，可以理解如何从MAC地址生成IPv6地址以及涉及的原理和标准。



## 22.假设结点A和结点B在同一条以太网链路上，都支持IPv6协议机制。

结点A的本地站点地址为FEC0:：1:0250:3EFF:FEE4:4C00，链路层地址为00-50-3E-E4-4C-00：。
结点B的本地站点地址为FEC0：1:0250:3EFF:FEE4:4B01，链路层地址为00-50-3E-E4-4B-01。
请写出结点A解析结点B的MAC地址的工作过程



结点A要解析结点B的MAC地址，使用的是IPv6的邻居发现协议（Neighbor Discovery Protocol，NDP）。这个协议包括发送邻居请求（Neighbor Solicitation，NS）和接收邻居通告（Neighbor Advertisement，NA）消息。以下是详细的步骤：

步骤详解

1. **准备邻居请求（NS）消息**
   - **源IPv6地址**：FEC0::1:0250:3EFF:FEE4:4C00（结点A的本地站点地址）
   - **目标IPv6地址**：FEC0::1:0250:3EFF:FEE4:4B01（结点B的本地站点地址）
   - **目标链路层地址**：未填（此时不确定）

2. **计算目标IPv6地址的请求节点多播地址**
   - 目标IPv6地址：FEC0::1:0250:3EFF:FEE4:4B01
   - 提取最后24位：E4:4B01
   - 生成请求节点多播地址：FF02::1:FF**E4:4B01**

3. **发送邻居请求（NS）消息**
   - **目的地址**：FF02::1:FFE4:4B01（请求节点多播地址）
   - **NS消息内容**：包含目标IPv6地址和源IPv6地址
   - **链路层目的地址**：33:33:FF:E4:4B:01（对应IPv6多播地址的以太网地址）

4. **结点B接收邻居请求（NS）消息**
   - 结点B监听并接收发送给FF02::1:FFE4:4B01多播地址的消息
   - 解析并确认消息中的目标IPv6地址是自己（FEC0::1:0250:3EFF:FEE4:4B01）

5. **准备邻居通告（NA）消息**
   - **源IPv6地址**：FEC0::1:0250:3EFF:FEE4:4B01（结点B的本地站点地址）
   - **目的IPv6地址**：FEC0::1:0250:3EFF:FEE4:4C00（结点A的本地站点地址）
   - **目标链路层地址**：00-50-3E-E4-4B-01（结点B的链路层地址）

6. **发送邻居通告（NA）消息**
   - **目的地址**：FEC0::1:0250:3EFF:FEE4:4C00（结点A的本地站点地址）
   - **NA消息内容**：包含目标IPv6地址和源IPv6地址以及目标链路层地址
   - **链路层目的地址**：00-50-3E-E4-4C-00（结点A的链路层地址）

7. **结点A接收邻居通告（NA）消息**
   - 结点A接收到来自结点B的NA消息
   - 解析NA消息，提取结点B的MAC地址：00-50-3E-E4-4B-01
   - 将结点B的MAC地址与其IPv6地址FEC0::1:0250:3EFF:FEE4:4B01关联在一起，更新邻居缓存（Neighbor Cache）

知识点考察

1. **IPv6邻居发现协议 (NDP)**
   - IPv6中的NDP协议替代了IPv4中的ARP协议，用于解析IPv6地址到链路层地址。
   - 包括五种ICMPv6消息：Router Solicitation、Router Advertisement、Neighbor Solicitation、Neighbor Advertisement、Redirect。

2. **请求节点多播地址 (Solicited-Node Multicast Address)**
   - 生成方法：前缀为FF02::1:FF00:0/104，加上目标地址的最后24位。
   - 作用：减少多播范围，仅对目标节点发送请求。

3. **邻居请求 (Neighbor Solicitation, NS) 和 邻居通告 (Neighbor Advertisement, NA) 消息**
   - NS消息：请求目标节点的链路层地址。
   - NA消息：响应NS消息，提供自己的链路层地址。

4. **链路层地址解析**
   - 利用NDP消息中的源地址和目标地址进行解析和绑定。
   - 维护邻居缓存（Neighbor Cache），存储已解析的地址对。

通过以上步骤，结点A能够通过IPv6邻居发现协议解析到结点B的MAC地址，并在其邻居缓存中保存该信息以供后续通信使用。



## 23.试编写C语言函数，实现下列功能：（1）判断给定的IP（点分十进制形式）是否为多播地址（2）判断给定的以太网地址是否为以太网多播地址

C语言函数实现

下面是两个C语言函数，用于实现判断给定的IP地址是否为多播地址以及判断给定的以太网地址是否为以太网多播地址的功能。

1. **判断给定的IP（点分十进制形式）是否为多播地址**
   - 多播IP地址范围是`224.0.0.0`到`239.255.255.255`。
   - 这可以通过检查IP地址的第一个八位组是否在`224`到`239`之间来实现。

2. **判断给定的以太网地址是否为以太网多播地址**
   - 以太网多播地址的最低有效位（最右边的一位）为1。
   - 以太网地址通常表示为六个十六进制数，用冒号分隔。

代码实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// 函数声明
bool isMulticastIP(const char *ip);
bool isMulticastMAC(const char *mac);

int main() {
    // 测试IP地址和MAC地址
    const char *testIP1 = "224.0.0.1";
    const char *testIP2 = "192.168.1.1";
    const char *testMAC1 = "01:00:5E:00:00:00";
    const char *testMAC2 = "00:1A:2B:3C:4D:5E";

    // 判断IP地址是否为多播地址
    if (isMulticastIP(testIP1)) {
        printf("IP %s 是多播地址\n", testIP1);
    } else {
        printf("IP %s 不是多播地址\n", testIP1);
    }

    if (isMulticastIP(testIP2)) {
        printf("IP %s 是多播地址\n", testIP2);
    } else {
        printf("IP %s 不是多播地址\n", testIP2);
    }

    // 判断MAC地址是否为以太网多播地址
    if (isMulticastMAC(testMAC1)) {
        printf("MAC %s 是以太网多播地址\n", testMAC1);
    } else {
        printf("MAC %s 不是以太网多播地址\n", testMAC1);
    }

    if (isMulticastMAC(testMAC2)) {
        printf("MAC %s 是以太网多播地址\n", testMAC2);
    } else {
        printf("MAC %s 不是以太网多播地址\n", testMAC2);
    }

    return 0;
}

// 判断给定的IP（点分十进制形式）是否为多播地址
bool isMulticastIP(const char *ip) {
    unsigned int octet1;
    sscanf(ip, "%u", &octet1); // 只读取第一个八位组
    return (octet1 >= 224 && octet1 <= 239);
}

// 判断给定的以太网地址是否为以太网多播地址
bool isMulticastMAC(const char *mac) {
    unsigned int macBytes[6];
    sscanf(mac, "%x:%x:%x:%x:%x:%x", &macBytes[0], &macBytes[1], &macBytes[2], &macBytes[3], &macBytes[4], &macBytes[5]);
    // 检查第一字节的最低有效位
    return (macBytes[0] & 1) != 0;
}
```

解释

1. **`isMulticastIP`函数**
   - 该函数接受一个字符串形式的IP地址，使用`sscanf`解析出第一个八位组。
   - 判断第一个八位组是否在`224`到`239`之间，如果是，则该IP地址为多播地址。

2. **`isMulticastMAC`函数**
   - 该函数接受一个字符串形式的MAC地址，使用`sscanf`解析出六个十六进制字节。
   - 检查第一字节的最低有效位（使用按位与操作`& 1`），如果为1，则该MAC地址为多播地址。

测试

上述代码在`main`函数中提供了测试用例，可以通过运行程序验证函数的正确性。



## 24.一棵PIM-SM共享树，如下图所示。假定R3为共享树的根，请写出各路由器关于（*，235.80.1.1）共享树的多播路由表的信息：若指定路由器DR（如R2，R4，R5）检测出多播178.16.1.1发送多播分组的速率超过某一门限值，则建立一棵基于源的SPT树。假设从该源到各个多播组成员的SPT树已经建好，请写出关于多播源（178.16.1.1，235.80.1.1）的多播路由表的信息。⭐

![Snipaste_2024-06-26_19-10-49](https://s2.loli.net/2024/06/26/SaO8kT4hHejnRov.jpg)

题目要求

1. 写出各路由器关于（*，235.80.1.1）共享树的多播路由表的信息。
2. 假定从指定路由器DR（如R2，R4，R5）检测出多播178.16.1.1发送多播分组的速率超过某一门限值，建立一棵基于源的SPT树。写出关于多播源（178.16.1.1，235.80.1.1）的多播路由表的信息。

**共享树的多播路由表**

| 路由器 | （*，G）        | RP地址     | RPF邻居地址  | 上游接口 | 下游接口 |
| ------ | --------------- | ---------- | ------------ | -------- | -------- |
| R1     | (*, 235.80.1.1) | 178.16.8.1 | 178.16.3.9   | a        | b        |
| R2     | (*, 235.80.1.1) | 178.16.8.1 | 178.16.2.6   | a        | c        |
| R3     | (*, 235.80.1.1) | 178.16.8.1 | 0.0.0.0      | NULL     | a,b,c    |
| R4     | (*, 235.80.1.1) | 178.16.8.1 | 178.16.5.14  | c        | d        |
| R5     | (*, 235.80.1.1) | 178.16.8.1 | 178.16..6.17 | a        | b        |

R3作为RP路由器，邻居地址为默认路由，没有上游接口，所有粗线接口为下游接口；

RPF邻居地址：向RP路由器方向的邻居路由器的接口地址。

上游接口：向RP路由器方向的接口地址。

下游接口：直接连接组成员的接口 + 粗线接口。

**源树的多播路由表**

| 路由器 | （S，G）                 | RPF邻居地址  | 上游接口 | 下游接口 |
| ------ | ------------------------ | ------------ | -------- | -------- |
| R1     | (178.16.1.1, 235.80.1.1) | 178.16.3.9   | a        | b        |
| R2     | (178.16.1.1, 235.80.1.1) | 178.16.4.12  | b        | c        |
| R3     | (178.16.1.1, 235.80.1.1) | 178.16.5.13  | b        | c        |
| R4     | (178.16.1.1, 235.80.1.1) | 178.16.7.22  | b        | a,c,d    |
| R5     | (178.16.1.1, 235.80.1.1) | 178.16..6.17 | a        | b        |
| R6     | (178.16.1.1, 235.80.1.1) | 0.0.0.0      | b        | a        |

R6直接连接源，邻居地址为默认路由。

下游接口：直接连接组成员的接口 + 细线接口。







## 24.例如：三台主机，在时间0收到查询报文，对每一个组的随机响应时间，如下图所示。若每个主机发送响应报文，则需要多少个报文？若使用延迟响应则只需要多少个报文？⭐

![Snipaste_2024-06-26_19-45-06](https://s2.loli.net/2024/06/26/kFZ5b1z9UiSjWaC.jpg)









> 解题关键：启动延迟响应后，针对于一个多播组，只需要发送一个响应报文即可。

解析步骤

1. 查询报文：在时间0，所有主机收到一个查询报文。每个主机都会为每个组选择一个随机响应时间。IGMP（Internet Group Management Protocol）是用于管理主机和路由器之间多播组成员关系的协议。

2. 随机响应时间：每个主机为每个组选择一个随机响应时间。假设三个主机A、B、C分别为各自的多播组选择响应时间，响应时间为随机值，用于减少冲突。

IGMP的基本原理

- 查询报文（Query Message）：由路由器发送给所有主机，询问哪些主机是某个多播组的成员。
- 成员报告（Membership Report）：主机在收到查询报文后，选择一个随机响应时间，在这个时间内发送成员报告。如果在等待期间收到其他主机的报告，则取消自己的报告，以减少冗余报文。

主机的随机响应时间

- 主机A：
  - 225.14.0.0 - 30秒
  - 228.42.0.0 - 12秒
  - 230.43.0.0 - 80秒

- 主机B：
  - 228.42.0.0 - 48秒
  - 251.71.0.0 - 50秒

- 主机C：
  - 225.14.0.0 - 62秒
  - 230.43.0.0 - 70秒

不使用延迟响应

若每个主机在自己的随机时间内发送响应报文，则总共需要发送：

- 主机A：3个报文（225.14.0.0，228.42.0.0，230.43.0.0）
- 主机B：2个报文（228.42.0.0，251.71.0.0）
- 主机C：2个报文（225.14.0.0，230.43.0.0）

总共需要：3 + 2 + 2 = 7 个报文。

使用延迟响应

通过选择最小的随机响应时间来减少报文数量。如下：

- 225.14.0.0
  - 主机A：30秒
  - 主机C：62秒
  - 最小响应时间：30秒（由主机A发送）

- 228.42.0.0
  - 主机A：12秒
  - 主机B：48秒
  - 最小响应时间：12秒（由主机A发送）

- 230.43.0.0
  - 主机A：80秒
  - 主机C：70秒
  - 最小响应时间：70秒（由主机C发送）

- 251.71.0.0
  - 主机B：50秒
  - 只有主机B参与，50秒（由主机B发送）

总共需要：1（225.14.0.0） + 1（228.42.0.0） + 1（230.43.0.0） + 1（251.71.0.0） = 4 个报文。

知识点

- IGMP协议：用于在主机和相邻路由器之间建立和维护多播组成员关系。
- 查询-响应机制：路由器发送查询报文，主机根据随机响应时间发送成员报告，减少了不必要的报文冲突。
- 随机响应时间：通过随机响应时间，主机可以减少同时发送报文的概率，从而降低冲突和网络拥塞。

结论

通过延迟响应机制，可以显著减少IGMP成员报告的数量，从而优化网络性能：

- 不使用延迟响应：7个报文
- 使用延迟响应：4个报文





## 25.在 DVMRP 多播路由协议中，路由器对多播分组的处理过程中，需要进行 RPF 检查。根据 RPF 检查的结果，决定对分组进行丢弃还是转发。本题所使用的网络环境如图 9-31 所示。

路由器 RA 从接口 S0 收到了来自192.168.0.22 的多播分组，从接口 S1 收到了来自 172.16.32.66
的多播分组。路由器 RA 分别对这两个多播分组进行 RPF 检查，请对路由器的行为进行判断（丢弃还是转发）
(1)来自源 192.168.0.22 分组
(2)来自源 172.16.32.66 分组

![image-20240629104856132](https://s2.loli.net/2024/06/29/NDGJCoTbSavRUr4.png)

路由器RA的单播路由表

| 目的网络         | 接口 |
| ---------------- | ---- |
| 192.168.0.0/16   | E1   |
| 172.16.32.0/24   | S1   |
| 202.194.210.0/24 | E0   |



解析步骤

1. 了解DVMRP和RPF检查：
   - DVMRP（Distance Vector Multicast Routing Protocol）是一种**基于距离矢量的多播路由协议**。
   - RPF（Reverse Path Forwarding）检查用于确保多播分组是从源地址的最佳路径上到达的。
   - RPF检查步骤：对于一个多播分组，路由器检查该分组是否从到达路由器的最佳路径接口到达。如果是，则转发；如果不是，则丢弃。

2. 查看路由器RA的单播路由表：

   | 目的网络         | 接口 |
   | ---------------- | ---- |
   | 192.168.0.0/16   | E1   |
   | 172.16.32.0/24   | S1   |
   | 202.194.210.0/24 | E0   |

3. 进行RPF检查：

   (1) 来自源192.168.0.22的分组：
   - 检查RA的单播路由表，192.168.0.22属于192.168.0.0/16网段，最佳路径接口是E1。
   - 实际接收接口：S0。
   - RPF检查失败，因为最佳路径接口（E1）与实际接收接口（S0）不同。
   - 结论：丢弃分组。

   (2) 来自源172.16.32.66的分组：
   - 检查RA的单播路由表，172.16.32.66属于172.16.32.0/24网段，最佳路径接口是S1。
   - 实际接收接口：S1。
   - RPF检查通过，因为最佳路径接口（S1）与实际接收接口（S1）相同。
   - 结论：转发分组。

最终结果表格

| 源地址       | 接口 | RPF检查结果 | 动作 |
| ------------ | ---- | ----------- | ---- |
| 192.168.0.22 | S0   | 失败        | 丢弃 |
| 172.16.32.66 | S1   | 通过        | 转发 |

考察的知识点

- DVMRP协议：了解如何进行多播路由以及路由器的多播路由表和单播路由表之间的关系。
- RPF检查：掌握如何使用RPF检查来确定多播分组是否从最佳路径接口到达，以决定是丢弃还是转发该分组。
- 网络路由表的理解和应用：理解路由表的内容并应用于实际的多播路由决策中。



## 26。以太网上的路由器收到多播IP分组，其GroupID为226.17.18.4。当主机检查其多播组表时找到了这个地址，请回答下列问题：⭐

（1）试说明路由器怎样将这个IP分组封装成以太网块，并将它发送给各接收结点？试给出这个以太网顿的所有字段的值。

（2）该路由器转发接口的IP地址是185.22.5.6，而对应的物理地址为4A-22-45-12-E1-E2。这个路由器需要ARP的服务吗？

（3）若路由器在它的组表中找不到GroupID时会怎么样？





**(1) 路由器如何将多播IP分组封装成以太网帧并发送给接收节点**

**步骤**：
1. 确定以太网多播地址：
   - IPv4多播地址范围：224.0.0.0到239.255.255.255
   - 对应的以太网多播地址范围：01:00:5E:00:00:00到01:00:5E:7F:FF:FF

2. 计算以太网多播地址：
   - 多播IP地址：226.17.18.4（转换为二进制：11100010.00010001.00010010.00000100）
   - 去掉前25位（11100010.00010001.0001），取后23位（00 010010.00000100）
   - 以太网多播地址前24位固定为：**01:00:5E**
   - 以太网多播地址后24位由IP地址的后23位构成，高位补0
   - 结果：01:00:5E:12:04

**封装后的以太网帧字段**：
   - 目标MAC地址：01:00:5E:12:04
   - 源MAC地址：4A:22:45:12:E1:E2（路由器的物理地址）
   - 以太网类型：0x0800（表示封装的是IPv4分组）
   - IP数据部分：原始的多播IP分组数据

(2) 路由器是否需要ARP的服务

**ARP（地址解析协议）**：
- 用于将IP地址解析为MAC地址。
- 多播组的MAC地址是固定的，通过IP地址计算得出。

**情景分析**：
- 路由器的IP地址：185.22.5.6
- 路由器的物理地址：4A-22-45-12-E1-E2

路由器发送多播分组时，需要将多播IP地址转换为对应的以太网多播MAC地址。此转换不需要ARP，因为多播MAC地址通过算法直接从IP地址计算得到。因此：
- 结论：路由器在发送多播分组时，不需要ARP服务。

(3) 路由器在组表中找不到GroupID时的行为

**组表（Multicast Group Table）**：
- 路由器维护一个多播组表，记录多播组及其成员信息。

**情景**：
- 收到的多播IP分组的GroupID为226.17.18.4
- 路由器检查其组表，未找到该GroupID

**行为**：
- 丢弃分组：路由器将丢弃该多播分组，因为没有接收该组分组的成员。

总结

**表格形式展示结果**：

| 问题                    | 回答                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 封装成以太网帧的字段    | - 目标MAC地址：01:00:5E:12:04<br>- 源MAC地址：4A:22:45:12:E1:E2<br>- 以太网类型：0x0800 |
| 路由器是否需要ARP的服务 | 否，路由器可以通过算法直接计算出多播MAC地址                  |
| 找不到GroupID时的行为   | 丢弃该多播分组                                               |



## 27.IPV6的地址自动配置是什么？举个例子

IPv6的地址自动配置是一种机制，使得设备能够自动生成和配置IPv6地址，而无需手动干预或使用DHCPv6服务器。这种机制称为无状态地址自动配置（Stateless Address Autoconfiguration，SLAAC）。它利用路由器通告（Router Advertisement，RA）消息来指导设备生成自己的IPv6地址。以下是详细的解释和一个例子：

无状态地址自动配置（SLAAC）

SLAAC是IPv6中一种常见的地址配置方式。设备使用链路本地地址（Link-Local Address）与邻居发现协议（Neighbor Discovery Protocol，NDP）进行通信，并从路由器获得网络前缀，然后自行生成全局唯一的IPv6地址。

步骤

1. 生成链路本地地址：
   设备首先生成一个链路本地地址，链路本地地址以`FE80::/10`开头，通常基于设备的MAC地址生成。

2. 发送路由器请求（Router Solicitation，RS）：
   设备发送RS消息，以请求网络中的路由器提供配置信息。

3. 接收路由器通告（RA）：
   路由器响应RS消息，发送RA消息，包含网络前缀信息、MTU等。

4. 生成全局唯一地址：
   设备根据RA消息中的前缀信息和自己的接口标识符（通常基于MAC地址）生成一个全局唯一的IPv6地址。

5. 重复地址检测（DAD）：
   设备在网络上广播新生成的IPv6地址，进行重复地址检测，以确保该地址在网络中是唯一的。

举例

假设有一台设备的MAC地址为`00:1A:2B:3C:4D:5E`，它连接到一个IPv6网络，网络的前缀为`2001:db8:abcd:0012::/64`。

1. 生成链路本地地址：
   设备基于MAC地址生成链路本地地址。MAC地址为`00:1A:2B:3C:4D:5E`，插入`FFFE`中间，并将第七位翻转，生成接口标识符`021A:2BFF:FE3C:4D5E`。
   - 链路本地地址为：`FE80::021A:2BFF:FE3C:4D5E`

2. 发送路由器请求（RS）：
   设备发送RS消息，源地址为链路本地地址，目的地址为全路由器组播地址`ff02::2`。

3. 接收路由器通告（RA）：
   路由器接收到RS消息后，发送RA消息。假设RA消息中的前缀信息为`2001:db8:abcd:0012::/64`。

4. 生成全局唯一地址：
   设备根据收到的前缀`2001:db8:abcd:0012::/64`和自己的接口标识符生成全局唯一地址：
   - 全局唯一地址为：`2001:db8:abcd:0012:021A:2BFF:FE3C:4D5E`

5. 重复地址检测（DAD）：
   设备在网络上广播包含新生成地址的NS（Neighbor Solicitation）消息，如果未收到NA（Neighbor Advertisement）消息，表示地址在网络中是唯一的。

总结

IPv6的地址自动配置机制使设备可以在没有DHCP服务器的情况下，自动生成和配置自己的IPv6地址。通过这种机制，网络管理更加简便，尤其是在大规模网络中。以下是示例中的地址生成过程：

- 链路本地地址：`FE80::021A:2BFF:FE3C:4D5E`
- 全局唯一地址：`2001:db8:abcd:0012:021A:2BFF:FE3C:4D5E`

这一过程确保了设备在连接IPv6网络时能够自动配置并使用合法的IPv6地址。



## 28.在IPV6中，网络接口标识是个很重要的东西，很多地址的生成都用到了它，具体有哪些应用？举例说明

在IPv6中，网络接口标识符（Interface Identifier, IID）是一个关键的组成部分，它用于生成各种类型的IPv6地址。网络接口标识符通常是64位长，在一些常见的IPv6地址类型中都有广泛的应用。下面是几种主要应用及其具体例子：

1. **无状态地址自动配置（SLAAC）**

   IPv6的无状态地址自动配置允许设备在没有DHCPv6服务器的情况下自动配置自己的地址。IID在这个过程中扮演了重要角色。

   举例：
   假设一个设备的MAC地址是00-11-22-33-44-55。

   1. 转换为**EUI-64格式**：
      - 首先，将MAC地址的前24位（00-11-22）和后24位（33-44-55）分开。
      - 插入“FFFE”到中间，变成00-11-22-FF-FE-33-44-55。
      - 然后将第7位翻转（将00的第7位从0变成1），变成02-11-22-FF-FE-33-44-55，**即为网络接口标识符**。

   2. 生成完整的IPv6地址：
      - 假设路由器发送的前缀是2001:db8:1:2::/64。
      - 最终生成的IPv6地址是2001:db8:1:2:0211:22FF:FE33:4455。

2. **链路本地地址**

   链路本地地址用于**同一链路上的设备之间的通信**，自动配置的链路本地地址使用接口标识符。

   举例：
   对于MAC地址00-11-22-33-44-55，生成的链路本地地址是：

   - 前缀：FE80::/64
   - **接口标识符：0211:22FF:FE33:4455**
   - 完整地址：FE80::0211:22FF:FE33:4455

3. **唯一本地地址（ULA）**

   唯一本地地址用于内部网络通信，类似于IPv4的私有地址。

   举例：
   假设一个设备的MAC地址为00-11-22-33-44-55，使用ULA的前缀是FD00::/64。

   - 前缀：FD00::/64
   - 接口标识符：0211:22FF:FE33:4455
   - 完整地址：FD00::0211:22FF:FE33:4455

4. **IPv6多播地址**

   为了生成与给定MAC地址对应的IPv6多播地址，需要遵循以下步骤。具体来说，我们将构建一个被请求节点多播地址，这个地址的格式为 `FF02::1:FFXX:XXXX`，其中 `XX:XXXX` 是设备MAC地址的后24位。

   步骤详细说明

   1. 提取设备MAC地址的后24位

   给定的MAC地址是 `00-11-22-33-44-55`。

   我们需要提取后24位，即最后三个字节（十六进制数）：
   - 33 (第四组，8位)
   - 44 (第五组，8位)
   - 55 (第六组，8位)

   所以，后24位为： `33-44-55`。

   2. 将后24位表示成 IPv6 的16位块

   IPv6地址的每一部分都是16位，因此我们需要将后24位分成两个部分来填充最后的16位：
   - `33-44` 作为第一部分
   - `55` 作为第二部分的前8位，后8位用零填充（表示成`55 00`）

   所以，`33-44-55` 在 IPv6 中表示为 `33 44` 和 `55 00`。

   3. 将提取出的后24位嵌入到IPv6多播前缀中

   IPv6多播地址的格式为 `FF02::1:FFXX:XXXX`，其中 `XX:XXXX` 是 MAC 地址的最后24位。

   具体嵌入如下：
   - 前缀部分： `FF02::1:FF`
   - 嵌入后24位部分： `33:4455`

   4. 组合成完整的IPv6多播地址

   将上述部分组合在一起得到完整的IPv6多播地址：

   `FF02::1:FF33:4455`

   最终的IPv6多播地址

   设备的MAC地址为 `00-11-22-33-44-55` 对应的IPv6多播地址是：

   **`FF02::1:FF33:4455`**

   总结

   生成IPv6多播地址的关键步骤是提取MAC地址的后24位并将其嵌入到 `FF02::1:FFXX:XXXX` 这一固定的多播地址格式中。这样，我们确保生成的多播地址正确反映了设备的MAC地址信息，并符合IPv6多播地址的规范。



5. **被请求结点的多播地址**

被请求节点多播地址（Solicited-Node Multicast Address）是一种特殊的IPv6多播地址，用于邻居发现协议（NDP）中的地址解析。它与接口标识符密切相关。以下是详细解释：

生成被请求节点多播地址的步骤

1. 前缀：被请求节点多播地址的固定前缀为`FF02::1:FF00:0/104`。
2. 接口标识符：使用IPv6地址的最后24位，即接口标识符的最后24位。

具体步骤

1. 确定前缀：`FF02::1:FF00:0/104`。这个前缀的前104位是固定的，表示这是一个链路本地范围的多播地址。
2. 提取接口标识符的最后24位：从给定的IPv6地址中提取最后24位。这些位将被用于生成多播地址的最后24位。

示例

假设IPv6地址为 `2001:0db8:85a3:0000:0000:8a2e:0370:7334`：

1. 提取最后24位：从`0370:7334`中提取最后24位，即`0x7334`（`7334`用二进制表示为`0111 0011 0011 0100`）。
2. 生成多播地址：将这些位附加到前缀`FF02::1:FF00:0/104`上，生成多播地址。

具体步骤如下：

- IPv6地址：`2001:0db8:85a3:0000:0000:8a2e:0370:7334`
- 提取最后24位：`0x7334`
- 被请求节点多播地址：`FF02::1:FF00:0000` + `0370:7334`
- 结果：`FF02::1:FF37:0734`

总结

生成被请求节点多播地址的关键步骤包括：

1. 使用固定的前缀 `FF02::1:FF00:0/104`。
2. 提取给定IPv6地址的最后24位。
3. 将提取的24位附加到前缀后，生成完整的被请求节点多播地址。

被请求节点多播地址用于IPv6网络中的邻居发现协议，帮助在同一链路上的设备进行高效的地址解析和邻居发现。



6. **DHCPv6**

虽然DHCPv6可以为设备分配地址，但它也可以使用接口标识符来确保每个设备获得唯一的IPv6地址。

举例：
假设DHCPv6服务器分配前缀2001:db8:1:2::/64。

- DHCPv6服务器使用接口标识符0211:22FF:FE33:4455。
- 最终地址：2001:db8:1:2:0211:22FF:FE33:4455。

1. IPv6临时地址（隐私扩展）

   为了保护用户隐私，IPv6可以生成临时地址，这些地址使用随机生成的IID。

   举例：
   生成的临时地址：

   ```
   - 前缀：2001:db8:1:2::/64
   - 随机IID：1234:5678:9abc:def0
   - 完整地址：2001:db8:1:2:1234:5678:9abc:def0。
   ```

总结

网络接口标识符在IPv6地址生成中具有广泛的应用，不同的类型地址使用接口标识符来确保地址的唯一性和自动配置。通过这些例子，可以看出接口标识符在无状态地址自动配置、链路本地地址、唯一本地地址、多播地址、DHCPv6分配以及临时地址生成中的重要性。



## 29.若 IPv6 分组由基本首部和 TCP 报文段组成，假设 TCP 报文段的总长度为 256B。试表示这个分组，并给出所能确定字段的值

IPv6分组由基本首部和TCP报文段组成，可以表示为如下形式：

```
+---------------------------------+
| IPv6 基本首部                   |
+---------------------------------+
| TCP 报文段                      |
+---------------------------------+
```

IPv6 基本首部 (IPv6 Header)
IPv6基本首部的长度是固定的40字节。以下是根据已知信息填写的字段：

- 版本 (Version): 4位，IPv6的版本号为6。
- 通信量类别 (Traffic Class): 8位，用于区分不同类型的流量，默认设置为0。
- 流标签 (Flow Label): 20位，用于标记数据流，默认设置为0。
- 有效载荷长度 (Payload Length): 16位，表示IPv6有效载荷（包括TCP报文段）的长度。对于256字节的TCP报文段，Payload Length字段应为256。
- 下一个首部 (Next Header): 8位，表示紧接在IPv6基本首部后的下一个首部类型。对于TCP，Next Header字段的值为6。
- 跳限制 (Hop Limit): 8位，表示数据包在网络中可经过的最大跳数。通常设置为默认值64。
- 源地址 (Source Address): 128位，表示发送数据包的源IPv6地址。
- 目的地址 (Destination Address): 128位，表示接收数据包的目的IPv6地址。

TCP 报文段 (TCP Segment)
TCP报文段的长度为256字节，具体内容包括TCP首部和TCP数据部分。以下是TCP首部的基本字段：

- 源端口 (Source Port): 16位，表示发送方的端口号。
- 目的端口 (Destination Port): 16位，表示接收方的端口号。
- 序号 (Sequence Number): 32位，表示数据段的序列号。
- 确认号 (Acknowledgment Number): 32位，表示期望接收的下一个序列号。
- 数据偏移 (Data Offset): 4位，表示TCP首部的长度。
- 保留位 (Reserved): 6位，通常设置为0。
- 控制动位 (Control Bits): 6位，表示TCP的控制标志。
- 窗口大小 (Window Size): 16位，表示接收方愿意接收的窗口大小。
- 校验和 (Checksum): 16位，用于校验TCP报文段的完整性。
- 紧急指针 (Urgent Pointer): 16位，表示紧急数据的偏移量。

IPv6 基本首部示例
假设源地址和目的地址分别为 `2001:0db8:85a3:0000:0000:8a2e:0370:7334` 和 `2001:0db8:85a3:0000:0000:8a2e:0370:1234`，IPv6基本首部的表示如下：

```
+---------------------+---------------------+
|  版本 (6) | 通信量类别 (0) | 流标签 (0)      |
+---------------------+---------------------+
|   有效载荷长度 (256)        | 下一个首部 (6)  |
+---------------------+---------------------+
|  跳限制 (64)        | 源地址 (128位)      |
+---------------------+---------------------+
|              2001:0db8:85a3:0000:0000:8a2e:0370:7334           |
+---------------------+---------------------+
|  目的地址 (128位)                 |
+---------------------+---------------------+
|              2001:0db8:85a3:0000:0000:8a2e:0370:1234           |
+---------------------+---------------------+
```

TCP 报文段示例
假设源端口为12345，目的端口为80，序号和确认号为0，窗口大小为65535，TCP报文段的表示如下：

```
+---------------------+---------------------+
|  源端口 (12345)     | 目的端口 (80)       |
+---------------------+---------------------+
|  序号 (0)                            |
+---------------------+---------------------+
|  确认号 (0)                            |
+---------------------+---------------------+
| 数据偏移 (5) | 保留 (0) | 控制动位 (0)         |
+---------------------+---------------------+
|  窗口大小 (65535)       | 校验和 (0)         |
+---------------------+---------------------+
|  紧急指针 (0)                       |
+---------------------+---------------------+
|  TCP 数据 (可选)                     |
+---------------------+---------------------+
```

组合后的IPv6分组
IPv6分组包含IPv6基本首部和TCP报文段，如下：

```
+---------------------------------+
| IPv6 基本首部                   |
+---------------------------------+
| TCP 报文段                      |
+---------------------------------+
```

通过以上示例，可以表示IPv6分组及其相关字段的值。





## 补充题

## 第一章

### 1.设某路由器建立了如下路由表。这三列分别是目的网络、子网掩码和吓一跳路由器。若直接交付，则最后一列标识应当从哪个接口转发出去。

| 目的网络      | 子网掩码        | 下一跳路由器 |
| ------------- | --------------- | ------------ |
| 128.96.39.0   | 255.255.255.128 | 接口0        |
| 128.96.39.128 | 255.255.255.128 | 接口1        |
| 128.96.40.0   | 255.255.255.128 | R2           |
| 192.4.153.0   | 255.255.255.192 | R3           |
| *（默认）     | ——              | R4           |

现收到了5个分组，其目的站IP地址分别为：

```
（1）：128.96.39.10
（2）：128.96.40.12
（3）：128.96.40.151
（4）：192.4.153.17
（5）：192.4.153.90
```

试分别计算其下一跳。









答：根据给定的路由表，我们可以找到每个目的地址的下一跳路由器或接口。我们需要检查每个目的地址，并与路由表中的各个目的网络和子网掩码进行匹配，以找到适当的下一跳。

路由表
| 目的网络      | 子网掩码        | 下一跳路由器 |
| ------------- | --------------- | ------------ |
| 128.96.39.0   | 255.255.255.128 | 接口0        |
| 128.96.39.128 | 255.255.255.128 | 接口1        |
| 128.96.40.0   | 255.255.255.128 | R2           |
| 192.4.153.0   | 255.255.255.192 | R3           |
| *（默认）     | ——              | R4           |

**分析步骤**

1. 将每个IP地址与子网掩码按位进行与操作，得到网络地址。
2. 将得到的网络地址与路由表中的目的网络进行比较，找到匹配的项。
3. 使用最长前缀匹配（即最具体的匹配）。**最多匹配的**

**目的地址计算**

1. 目的地址：128.96.39.10
   - 子网掩码：255.255.255.128
   - 128.96.39.10 & 255.255.255.128 = 128.96.39.0
   - 匹配条目：128.96.39.0，下一跳为接口0。

2. 目的地址：128.96.40.12
   - 子网掩码：255.255.255.128
   - 128.96.40.12 & 255.255.255.128 = 128.96.40.0
   - 匹配条目：128.96.40.0，下一跳为R2。

3. 目的地址：128.96.40.151
   - 子网掩码：255.255.255.128
   - 128.96.40.151 & 255.255.255.128 = 128.96.40.128
   - 匹配条目：128.96.40.0，下一跳为R2。

4. 目的地址：192.4.153.17
   - 子网掩码：255.255.255.192
   - 192.4.153.17 & 255.255.255.192 = 192.4.153.0
   - 匹配条目：192.4.153.0，下一跳为R3。

5. 目的地址：192.4.153.90
   - 子网掩码：255.255.255.192
   - 192.4.153.90 & 255.255.255.192 = 192.4.153.64
   - **无匹配条目，使用默认路由，下一跳为R4**。

总结

| 目的地址      | 下一跳         |
| ------------- | -------------- |
| 128.96.39.10  | 接口0          |
| 128.96.40.12  | R2             |
| 128.96.40.151 | R2             |
| 192.4.153.17  | R3             |
| 192.4.153.90  | R4（默认路由） |

这样，通过计算每个目的地址与子网掩码的与操作，并与路由表进行匹配，我们可以确定每个目的地址的下一跳。



### 2.某单位分配到一个地址块 136.23.12.64/26。现在需要进一步划分 4 个一样大的子网。试问：

（1）每个子网的前缀有多长？
（2）每一个子网中有多少个地址？
（3）每一个子网的地址块是什么？
（4）每一个子网可分配给主机使用的最小地址和最大地址是什么？

对于地址块 136.23.12.64/26 的进一步划分，我们来逐步回答你的问题：

**（1）每个子网的前缀有多长？**

原始地址块的前缀长度是 26 位。现在需要划分成 4 个子网，即需要额外的 2 位来表示这 4 个子网：

\[ \text{新的子网前缀长度} = 26 + 2 = 28 \]

**（2）每一个子网中有多少个地址？**

原始地址块是 /26，即总共有 \( 2^{32-26} = 2^6 = 64 \) 个地址。

将 /26 划分成 /28，每个子网的地址数是 \( 2^{32-28} = 2^4 = 16 \) 个地址。

**（3）每一个子网的地址块是什么？**

根据新的前缀长度 /28，计算每个子网的**地址块**：也就是网络地址

- 子网 1：136.23.12.64/28
- 子网 2：136.23.12.80/28
- 子网 3：136.23.12.96/28
- 子网 4：136.23.12.112/28

**（4）每一个子网可分配给主机使用的最小地址和最大地址是什么？**

每个子网有 16 个地址，其中 2 个是网络地址和广播地址，所以可用地址数为 16 - 2 = 14 个。

计算每个子网的最小和最大可用地址：

- **子网 1**：
  - 网络地址：136.23.12.64
  - 第一个可用地址：136.23.12.65
  - 最后一个可用地址：136.23.12.78
  - 广播地址：136.23.12.79

- **子网 2**：
  - 网络地址：136.23.12.80
  - 第一个可用地址：136.23.12.81
  - 最后一个可用地址：136.23.12.94
  - 广播地址：136.23.12.95

- **子网 3**：
  - 网络地址：136.23.12.96
  - 第一个可用地址：136.23.12.97
  - 最后一个可用地址：136.23.12.110
  - 广播地址：136.23.12.111

- **子网 4**：
  - 网络地址：136.23.12.112
  - 第一个可用地址：136.23.12.113
  - 最后一个可用地址：136.23.12.126
  - 广播地址：136.23.12.127

这样，每个子网的地址范围和可用地址情况就清晰了。





### 3.一个3300位长的TCP报文传到IP层，加上160位的首部后成为数据报。下面的互联网由两个局域网通过路出器连接起来。但第二个局域网所能传送的最长数据恢中的数据部分只有1100位。因此，数据报在路由器必须进行分片。试问第二个局域网向其上层要传送多少比特的数据（这里的数据是指的局域网看得见的数据），说明这里的数据是指IP数据报还是TCP报文。

步骤 1：计算总的IP数据报长度

TCP报文加上IP首部：

总IP数据报长度 = 3300 + 160 = 3460 位

步骤 2：计算每个分片的数据部分的长度

由于第二个局域网的MTU为1100位，IP数据报需要进行分片。每个分片的总长度不能超过1100位，减去IP首部160位，剩余的数据部分长度为：

每个分片的数据部分长度 = 1100 - 160 = 940 位

但是数据部分必须是8位的整数倍，所以我们需要取小于等于940的最大8位整数倍：

最大8位整数倍 = 936 位

步骤 位 3：计算分片数量

我们需要计算总共多少个分片才能传输整个数据报。每个分片的数据部分为936位，剩余部分需要分片：

总数据长度 = 3300 位

分片数量 = 3300 / 936 ≈ 3.53

由于分片数量必须是整数，我们向上取整得到4个分片。

步骤 4：计算每个分片的实际长度

- 前三个分片的数据部分长度为936位，总长度为936 + 160 = 1096位。
- 最后一个分片的数据部分长度为3300 - 3 * 936 = 492位，总长度为492 + 160 = 652位。

最终数据量计算

- 前三个分片：3 * 1096 = 3288位
- 最后一个分片：652位

总计：

总传输数据量 = 3288 + 652 = 3940 位

数据部分的解释

这里的“数据”指的是IP数据报。第二个局域网看到的数据是指IP数据报的每个分片，包括IP首部和数据部分。

总结

第二个局域网向其上层传送的数据包括每个分片的IP首部和数据部分，总共需要传输3940位的数据。这里的数据是指**IP数据报**，包括TCP报文和每个IP分片的首部。



### 4.假设一个有效载荷为6000B的原IPv6分组，需要从结点A传送到结点B。已经探测到从A到B的路由MTU为1300B。从源节点A必须对这个IPv6分组进行分片处理，请间需要分几个分片？根据各分片情况填写表空白处。

为了对IPv6有效载荷进行分片，我们需要考虑IPv6的分片规则和MTU限制。IPv6的MTU为1300B，我们将详细解释分片过程，并计算出每个分片的相关参数。

解析步骤

步骤 1：计算分片所需的最大数据部分长度
**IPv6头部的固定长度是40B，分片头部的固定长度是8B**。因此，每个分片中有效载荷的最大长度为：

MTU - IPv6头部 - 分片头部 = 1300B - 40B - 8B = 1252B

步骤 2：确保分片的有效载荷长度为8B的倍数
IPv6分片的有效载荷长度必须是8B的倍数。1252B本身是8B的倍数，所以可以直接使用。

步骤 3：计算分片数量
总有效载荷为6000B，分片的有效载荷为1252B。因此，所需的分片数量为：

分片数量 = ⌈6000B / 1252B⌉ = 5 个分片

步骤 4：计算每个分片的偏移量和最后一个分片的长度

1. 前4个分片：
    - 每个分片的有效载荷长度为1252B
    - 总长度为1300B（包括IPv6头部和分片头部）

2. 最后一个分片：
    - 剩余有效载荷长度：6000B - 4 * 1252B = 992B
    - 总长度为1040B（包括IPv6头部和分片头部）

步骤 5：计算每个分片的分片偏移量
每个分片的偏移量（以8B为单位）为：

偏移量 = 分片起始位置 / 8

偏移量如下：

| 分片编号 | 数据部分长度 (B) | 分片偏移量（单位：8B） | M标志 | 总长度 (B) |
| -------- | ---------------- | ---------------------- | ----- | ---------- |
| 1        | 1252             | 0                      | 1     | 1300       |
| 2        | 1252             | 157                    | 1     | 1300       |
| 3        | 1252             | 314                    | 1     | 1300       |
| 4        | 1252             | 471                    | 1     | 1300       |
| 5        | 992              | 628                    | 0     | 1040       |

最终的分片表
根据上述计算结果，分片情况如下：

| 分片编号 | 数据部分长度 (B) | 分片偏移量（单位：8B） | M标志 | 总长度 (B) |
| -------- | ---------------- | ---------------------- | ----- | ---------- |
| 1        | 1252             | 0                      | 1     | 1300       |
| 2        | 1252             | 157                    | 1     | 1300       |
| 3        | 1252             | 314                    | 1     | 1300       |
| 4        | 1252             | 471                    | 1     | 1300       |
| 5        | 992              | 628                    | 0     | 1040       |

解释
- 分片编号：每个分片的顺序编号
- 数据部分长度 (B)：每个分片中实际有效载荷的长度
- 分片偏移量：每个分片中数据部分相对于原始数据的偏移量，以8B为单位
- M标志：More Fragments标志，表明是否有更多分片
- 总长度 (B)：每个分片的总长度，包括IPv6头部和分片头部

这个过程确保了IPv6数据包能够适应路径上的MTU限制，同时符合IPv6分片要求。



## 第三章

### 1.地址

![image-20240628214249660](https://s2.loli.net/2024/06/28/XhqJODg7xMTAPFc.png)



### 3.若一个主机网卡接口的 MAC 地址为 00-0D-87-04-6F-30，试写出该接口相对应的 EUI-64 格式的网络接口的标识符。假设该主机连接在前缀为 3FFE：3202:1001：：／48，并且在子网地址为 2 的网络上，请写出该主机接口的 IPv6 可聚合全局单播地址。

**将MAC地址转换为EUI-64格式**

1. 原始MAC地址：00-0D-87-04-6F-30

2. 插入FF:FE：将FF:FE插入到原始MAC地址的中间位置：

   00-0D-87-04-6F-30 → 00-0D-87-FF-FE-04-6F-30

3. 修改第7位：将原始MAC地址的第一个字节的第7位进行反转（即将局域/全局位由0改为1或由1改为0）。

   - 原始第一个字节：00
   - 二进制表示：0000 0000
   - 修改第7位：0000 0010 (二进制)
   - 转换回十六进制：02

   所以，修改后的EUI-64地址为：02-0D-87-FF-FE-04-6F-30

**生成IPv6可聚合全局单播地址**

1. 网络前缀：3FFE:3202:1001::/48
2. 子网地址：2（表示为：0002）

将这些部分组合起来：

**前缀 + 子网地址(16位) + EUI-64**

完整的IPv6地址为：

3FFE:3202:1001:0002:020D:87FF:FE04:6F30

详细解析

- MAC地址：00-0D-87-04-6F-30
  - 将FF:FE插入中间：00-0D-87-FF-FE-04-6F-30
  - 修改第一个字节的第7位：02-0D-87-FF-FE-04-6F-30
- EUI-64：02-0D-87-FF-FE-04-6F-30
- 网络前缀：3FFE:3202:1001::/48
- 子网地址：2（表示为0002）

组合为IPv6地址：

3FFE:3202:1001:0002:020D:87FF:FE04:6F30

结果

该主机接口的IPv6可聚合全局单播地址是：

3FFE:3202:1001:0002:020D:87FF:FE04:6F30



### 4.请写出 IPv6 单播地址 3FFE : 3201 : 3001 : 1 : 020D : 87FF : FE04 : 6F30 所对应的被请求多播地址

理解被请求多播地址 (Solicited-Node Multicast Address)

在IPv6中，每个单播或任播地址都有对应的被请求多播地址。被请求多播地址的前缀是固定的 `FF02::1:FF00:0/104`，后24位是单播地址的最后24位。这些地址用于局部链路上的邻居发现协议（Neighbor Discovery Protocol，NDP），特别是邻居请求消息。

提取单播地址的后24位

单播地址是： `3FFE:3201:3001:1:020D:87FF:FE04:6F30`

我们需要提取最后24位：

- 单播地址的最后一段是： `6F30`
- 把这段地址用二进制表示： `01101111 00110000`
- 我们需要的最后24位是： `FE04:6F30`中的最后6个十六进制字符： `04:6F30`

生成被请求多播地址

把提取的后24位加到被请求多播地址的前缀 `FF02::1:FF00:0/104` 后面：

- 前缀： `FF02::1:FF00:0`
- 加上最后24位： `04:6F30`

完整的被请求多播地址是：

`FF02::1:FF04:6F30`

结果

IPv6单播地址 `3FFE:3201:3001:1:020D:87FF:FE04:6F30` 所对应的被请求多播地址是：

```
FF02::1:FF04:6F30
```



### 5.若某主机地址为 581E : 1456 : 2314 : ABCD : : 1211，接口标识符为 64 位，试确定该主机所连的子网地址。

要确定某主机所连的子网地址，需要明确子网前缀和接口标识符。在IPv6中，通常采用 /64 的前缀长度，这意味着前64位是子网地址，后64位是接口标识符。

给定的信息：

- 主机的子网地址： `581E:1456:2314:ABCD::1211`
- 接口标识符为64位

步骤：

1. 拆分地址：
   - `581E:1456:2314:ABCD::1211` 这意味着前64位是子网地址，后64位是接口标识符。

2. 明确前64位（子网前缀）：
   - 子网前缀： `581E:1456:2314:ABCD::`（即 `581E:1456:2314:ABCD:0000:0000:0000:0000`）

3. 结果：
   - 子网前缀为： `581E:1456:2314:ABCD::/64`

解释：
- IPv6地址采用冒号分隔的八个16位块表示，共128位。
- `::` 表示连续的0块，在这种情况下是简写形式，可以扩展为合适的完整地址。
- 前64位用于标识子网地址，后64位用于标识特定接口。

因此，给定主机的子网地址为：

581E:1456:2314:ABCD::/64



### 6.兼容和映射地址

![image-20240628214614170](https://s2.loli.net/2024/06/28/zAsHhn2URuQFc4x.png)



### 7.若一个主机网卡接口的 MAC 地址为 F8-32-E4-9A-7B-86，试写出该接口相对应的 EUI-64 格式的网络接口标识符。假设该主机连接在前缀为 3FFE:3002:1100::/48，并且在子网地址为10的网络上，请写出该主机接口的IPV6 可聚合全局单播地址以及其所对应的被请求节点多播地址。











MAC 地址为 F8-32-E4-9A-7B-86 的主机

**EUI-64 格式的网络接口标识符**

1. MAC 地址：F8-32-E4-9A-7B-86
2. 插入 FF:FE：
   - F8:32:E4:9A:7B:86 -> F8:32:E4:FF:FE:9A:7B:86
3. 将第一个字节的第七位取反：
   - F8 (1111 1000) -> FA (1111 1010)
     所以 EUI-64 地址为：FA:32:E4:FF:FE:9A:7B:86

**可聚合全局单播地址**

前缀为 3FFE:3002:1100::/48，子网地址为 10 的网络上：

1. 前缀和子网：
   - 3FFE:3002:1100:000A::
2. 完整地址：
   - 3FFE:3002:1100:000A:FA32:E4FF:FE9A:7B86

**被请求节点多播地址**

IPv6 单播地址的被请求节点多播地址格式为：FF02::1:FFXX:XXXX，后24位是单播地址的后24位。

1. 单播地址的后24位：
   - FA32:E4FF:FE9A:7B86 -> 9A:7B:86
2. 多播地址：
   - FF02::1:FF9A:7B86



### 8.若一个主机网卡接口的MAC地址为00-0D-87-04-6F-30，试写出该接口相对应的EUI-64格式的网络接口标识符。假设该主机连接在前缀为3FFE：3202：1100：：/48，并且在子网地址为2的网络上，请写出该主机接口的IPv6可聚合全局单播地址和其所对应的被请求节点多播地址。

MAC 地址为 00-0D-87-04-6F-30 的主机

EUI-64 格式的网络接口标识符

1. MAC 地址：00-0D-87-04-6F-30
2. 插入 FF:FE：
   - 00:0D:87:04:6F:30 -> 00:0D:87:FF:FE:04:6F:30
3. 将第一个字节的第七位取反：
   - 00 (0000 0000) -> 02 (0000 0010)
     所以 EUI-64 地址为：02:0D:87:FF:FE:04:6F:30

可聚合全局单播地址

前缀为 3FFE:3202:1100::/48，子网地址为 2 的网络上：

1. 前缀和子网：
   - 3FFE:3202:1100:0002::
2. 完整地址：
   - 3FFE:3202:1100:0002:020D:87FF:FE04:6F30

被请求节点多播地址

1. 单播地址的后24位：
   - 020D:87FF:FE04:6F30 -> 04:6F:30
2. 多播地址：
   - FF02::1:FF04:6F30



### 9.若一个主机网卡接口的MAC地址为00-22-5B-86-EF-90，试写出该接口相对应的UI-64格式的网络接口标识符。假设该机连接在前为3FFE：3202：1100：：148，并且在了网地为5的网络上，请写出该主机接口的IPv6可聚合全局单播地址和其所对应的被请求节点多播地址及多播映射地址。⭐

MAC 地址为 00-22-5B-86-EF-90 的主机

EUI-64 格式的网络接口标识符

1. MAC 地址：00-22-5B-86-EF-90
2. 插入 FF:FE：
   - 00:22:5B:86:EF:90 -> 00:22:5B:FF:FE:86:EF:90
3. 将第一个字节的第七位取反：
   - 00 (0000 0000) -> 02 (0000 0010)
   所以 EUI-64 地址为：02:22:5B:FF:FE:86:EF:90

可聚合全局单播地址

前缀为 3FFE:3202:1100::/48，子网地址为 5 的网络上：

1. 前缀和子网：
   - 3FFE:3202:1100:0005::
2. 完整地址：
   - 3FFE:3202:1100:0005:0222:5BFF:FE86:EF90

被请求节点多播地址

1. 单播地址的后24位：
   - 0222:5BFF:FE86:EF90 -> 86:EF:90
2. 多播地址：
   - FF02::1:FF86:EF90

**多播映射地址**

多播映射地址用于将多播地址映射到以太网 MAC 地址。

1. 将多播地址的最后32位映射为MAC地址：
   - 33:33:86:EF:90



## 第四章

### 1.假设一个有效载荷为 6000B 的原IPv6 分组，从结点A传送到结点B。已经探测到从A到B的路由 MTU 为1300B。从源节点A必须对这个IPv6 分组进行分片处理，请问需要分几个分片？根据各分片情况填写表空白处

为了将一个有效载荷为6000字节的原IPv6分组从结点A传送到结点B，需要对其进行分片处理。IPv6数据包的标准头部长度是40字节。已知MTU（最大传输单元）为1300字节，意味着每个分片的总长度不能超过1300字节。

分析过程：

1. 计算每个分片的有效载荷大小：
   - 每个分片的总长度（包括头部）不能超过1300字节。
   - 每个分片的有效载荷大小 = 1300字节（MTU） - 40字节（IPv6头部） = 1260字节。

2. 计算需要的分片数量：
   - 原始有效载荷大小为6000字节。
   - 每个分片可以承载的有效载荷大小为1260字节。
   - 分片数量 = ⌈6000 / 1260⌉ = 5（向上取整，因为分片数量必须是整数）。

3. 计算每个分片的实际大小和分片偏移量：
   - 前4个分片的有效载荷大小均为1260字节。
   - 最后一个分片的有效载荷大小 = 6000 - 1260 * 4 = 960字节。
   - 分片偏移量单位为8字节（64位），所以每个分片的偏移量是前一个分片结束的位置，以8字节为单位计算。

分片情况：

| 分片编号 | 分片有效载荷大小（字节） | 分片偏移量（字节） | 分片偏移量（单位） | MF比特 |
| -------- | ------------------------ | ------------------ | ------------------ | ------ |
| 1        | 1260                     | 0                  | 0                  | 1      |
| 2        | 1260                     | 1260               | 157.5              | 1      |
| 3        | 1260                     | 2520               | 315                | 1      |
| 4        | 1260                     | 3780               | 472.5              | 1      |
| 5        | 960                      | 5040               | 630                | 0      |

注意：
- 分片偏移量必须是8字节的整数倍，因此需要调整分片的大小以确保偏移量是8字节的整数倍。
- MF比特（More Fragments）：表示后面是否还有更多的分片。前四个分片的MF比特设置为1，表示后面还有更多的分片。最后一个分片的MF比特设置为0，表示这是最后一个分片。

重新调整：

每个分片的有效载荷大小和偏移量必须是8字节的整数倍。我们可以将每个分片的有效载荷大小向下调整为8字节的整数倍。

重新计算后：

| 分片编号 | 分片有效载荷大小（字节） | 分片偏移量（字节） | 分片偏移量（单位） | MF比特 |
| -------- | ------------------------ | ------------------ | ------------------ | ------ |
| 1        | 1256                     | 0                  | 0                  | 1      |
| 2        | 1256                     | 1256               | 157                | 1      |
| 3        | 1256                     | 2512               | 314                | 1      |
| 4        | 1256                     | 3768               | 471                | 1      |
| 5        | 976                      | 5024               | 628                | 0      |

解释：
- 前四个分片的有效载荷大小调整为1256字节，确保分片偏移量是8字节的整数倍。
- 最后一个分片的有效载荷大小调整为976字节，确保所有分片的总有效载荷为6000字节。

总结：

总共有5个分片，每个分片的大小和偏移量已经调整为8字节的整数倍，并根据MTU限制和IPv6头部长度进行了适当的分片。



### 2.假设一个UPD数据报的数据部分为4392字节，分别用IPv4分组和IPv6分组在一个网络上传送，但此网络能够传送最大数据长度为1500字节。试问采用这两种协议进行传送时各自应当需要划分为多少片？分片的数据部分长度或有效载荷长度，分片偏移量的值和正标志应为何数值？

为了将一个UDP数据报分别通过IPv4和IPv6协议传送，需要考虑网络的MTU（最大传输单元）。下面将详细解析IPv4和IPv6的分片过程。

IPv4 分片

假设MTU为1500字节，IP首部为20字节。

1. 计算每个分片的数据部分长度：
   - 每个IPv4分片的数据部分长度必须是8字节的整数倍。
   - 由于MTU为1500字节，而IP首部为20字节，数据部分的最大长度为1500 - 20 = 1480字节。
   - 1480是8的整数倍，所以我们不需要进一步调整。

2. 计算分片数目：
   - 原始UDP数据报数据部分为4392字节。
   - 需要的分片数为 \(\lceil \frac{4392}{1480} \rceil = 3\) 个。

3. 每个分片的数据部分长度和偏移量：

   - 第一个分片：
     - 数据部分长度：1480字节
     - 分片偏移量：0
     - More Fragments (MF) 标志：1

   - 第二个分片：
     - 数据部分长度：1480字节
     - 分片偏移量：1480 / 8 = 185
     - More Fragments (MF) 标志：1

   - 第三个分片：
     - 数据部分长度：4392 - 2 * 1480 = 1432字节
     - 分片偏移量：2 * 1480 / 8 = 370
     - More Fragments (MF) 标志：0

IPv6 分片

IPv6与IPv4不同，分片由源节点完成，且不需要考虑分片数据部分长度是否为8的整数倍。

1. 计算每个分片的有效载荷长度：
   - 每个IPv6分片的有效载荷（包括分片首部）长度最大为1500字节。
   - IPv6分片首部为40字节。
   - 由于MTU为1500字节，而IPv6首部为40字节，分片首部为8字节，因此数据部分的最大长度为1500 - 40 - 8 = 1452字节。

2. 计算分片数目：
   - 原始UDP数据报数据部分为4392字节。
   - 需要的分片数为 \(\lceil \frac{4392}{1452} \rceil = 4\) 个。

3. 每个分片的有效载荷长度和偏移量：

   - 第一个分片：
     - 数据部分长度：1452字节
     - 分片偏移量：0
     - More Fragments (MF) 标志：1

   - 第二个分片：
     - 数据部分长度：1452字节
     - 分片偏移量：1452 / 8 = 181
     - More Fragments (MF) 标志：1

   - 第三个分片：
     - 数据部分长度：1452字节
     - 分片偏移量：2 * 1452 / 8 = 362
     - More Fragments (MF) 标志：1

   - 第四个分片：
     - 数据部分长度：4392 - 3 * 1452 = 1036字节
     - 分片偏移量：3 * 1452 / 8 = 543
     - More Fragments (MF) 标志：0

总结

IPv4 分片：

- 第一个分片：
  - 数据部分长度：1480字节
  - 分片偏移量：0
  - MF 标志：1

- 第二个分片：
  - 数据部分长度：1480字节
  - 分片偏移量：185
  - MF 标志：1

- 第三个分片：
  - 数据部分长度：1432字节
  - 分片偏移量：370
  - MF 标志：0

IPv6 分片：

- 第一个分片：
  - 数据部分长度：1452字节
  - 分片偏移量：0
  - MF 标志：1

- 第二个分片：
  - 数据部分长度：1452字节
  - 分片偏移量：181
  - MF 标志：1

- 第三个分片：
  - 数据部分长度：1452字节
  - 分片偏移量：362
  - MF 标志：1

- 第四个分片：
  - 数据部分长度：1036字节
  - 分片偏移量：543
  - MF 标志：0

以上是分别使用IPv4和IPv6协议进行传输时的分片过程及每个分片的详细信息。



## 第七章

### 1.给出D 类 IP 地址的表示范围？IP 多播如何将D 类IP 多播地址映射为以太网多播地址？若一个 IP 多播地址为226.24.60.9，其对应的以太网物理地址是什么？

1. **D 类 IP 地址表示范围及其映射**

D 类 IP 地址表示范围

D 类 IP 地址专用于多播，范围是从 224.0.0.0 到 239.255.255.255。

**IP 多播地址映射为以太网多播地址**

以太网多播地址的前25位是固定的，为 `01-00-5E`。**（00000001 00000000 01011110 `0`）后面额外有一位0**

D 类 IP 地址的前4位是1110，这与以太网多播地址的前25位无关。映射规则如下：

- 取D类IP地址的低23位，作为以太网多播地址的后23位。

具体映射步骤：
1. 取D类IP地址的最后23位。
2. 将其附加在`01-00-5E`的后面。

举例说明：对于D类IP地址 226.24.60.9

1. 将IP地址转换为二进制：
   - 226.24.60.9 = `11100010 00011000 00111100 00001001`

2. 取低23位：
   - `000 11000 00111100 00001001` （去掉前5位）

3. 以太网多播地址前25位为 `01-00-5E`，后23位为 `000 11000 00111100 00001001`：
   - `01-00-5E-18-3C-09`

因此，IP 多播地址 226.24.60.9 对应的以太网物理地址是 `01-00-5E-18-3C-09`。



### 2.试写出扩展首部追加 10B 的填充选项，其格式如何

扩展首部追加 10B 的填充选项格式

在IPv6中，扩展首部可以包含多个选项。若需要追加10字节的填充选项，可以使用填充选项的格式进行补充。填充选项一般用于**对齐目的**，填充选项的类型值为0（若只有一个字节）或1（若有多个字节）。

扩展首部的填充选项格式
1. 单字节填充:
   - 仅使用一个字节表示填充选项，类型值为0x00。

2. 多字节填充:
   - 第一个字节表示填充选项的类型值0x01。
   - 第二个字节表示填充选项的长度（总长度减去2，即填充字节数减去2）。
   - 后续字节为填充字节（全部为0x00）。

10字节填充选项具体格式：

- 总共需要10个字节，其中前两个字节用于类型和长度标记，剩下8个字节用于填充。

具体格式：
```
+----------+---------+---------+---------+---------+---------+---------+---------+---------+---------+
| Type (1) | Length (8) | 0x00    | 0x00    | 0x00    | 0x00    | 0x00    | 0x00    | 0x00    | 0x00    |
+----------+---------+---------+---------+---------+---------+---------+---------+---------+---------+
```
- 第一个字节（Type）：0x01
- 第二个字节（Length）：8
- 剩下8个字节为0x00

因此，扩展首部追加10B填充选项的格式为：
```
01 08 00 00 00 00 00 00 00 00
```

这样，这10个字节的填充选项可以用于IPv6扩展首部中，以确保正确的对齐和填充要求。





## 第八章

### 1.以太网上的路由器收到多播 IP 分组，其 GroupID 为 226.17.18.4。当主机检查其多播组表时找到了这个地址。请回答下列问题：

（1）试说明怎么将这个IP分组封装成以太网顿，并将它发送给各接受结点？试给出这人以太网的所有字段的值。

（2）该路由器转发接口的IP地址是185.22.5.6，而对应的物理地址为4A-22-45-12E1-E2。这人路由器需要ARP的服务吗?

（3）若路由器在它的组表中找不到GroupID时会怎么样？

**(1) 封装 IP 分组并发送给接收节点**

将 IP 地址 `226.17.18.4` 映射为以太网多播地址：

- IP 地址的二进制形式是 `11100010.00010001.00010010.00000100`。
- 取后 23 位 `10001000.10010000.00000100`。
- 映射到以太网地址时，前 25 位固定为 `01-00-5E-00-00-00`，加上 IP 地址的后 23 位：
  - 以太网地址：`01-00-5E-11-12-04`。

以太网帧字段：

- 目的地址: `01-00-5E-11-12-04`
- 源地址: 路由器的物理地址（例如 `4A-22-45-12-E1-E2`）
- 类型: 表示 IP 数据报 (通常为 `0x0800`)
- 数据: 包含的 IP 数据报
- 帧校验序列 (FCS): 校验值，用于错误检测

**(2) 是否需要 ARP 服务**

- 路由器转发接口的 IP 地址 `185.22.5.6` 对应的物理地址为 `4A-22-45-12-E1-E2`。这已知的映射表明不需要 ARP 服务，因为 IP 地址已经有对应的物理地址。

**(3) 如果找不到 GroupID**

- 如果路由器在组表中找不到 GroupID，它通常会丢弃该多播 IP 分组，因为没有与其相关联的接收者。在某些实现中，可能会记录或发出警告，但不会转发该分组。





## 第九章

### 1.一棵PIM-SM共享树如图9-32所示。假定R3为共享树的根，各路由器关于（*，230.80.1.1)共享树的路由表项的信息如表9-10所示。指定路由器DR（例如R2、R4、R5）检测出多播源172.16.66.1发送多播分组的速率超过某一门限值，则建立一棵基于源的SPT树。假设从该源到各个多播组成员的SPT树已经建好，请在表9-11中填写关于（172.16.66.1，230.80.1.1）的多播路由表。⭐

![image-20240629091531903](https://s2.loli.net/2024/06/29/Xrlp4zPQD5whR6E.png)

RP：RP是一个网络中的中间节点，用于汇聚多播流量，便于多播组成员的管理和数据分发。

RPF邻居：又称**下一跳路由器**，在特定路由器到源地址的最短路径中的下一个路由器，即为RPF邻居。

RPF邻居地址：RPF邻居与特定路由器相连的接口地址。

上游接口/下游接口：也是相对于最短路径来说的，向源方向的接口为上游接口，向多播组方向的接口为下游接口。

**答案解析：**

在源树中，如果直接与源相连接，则该路由器的上游接口为Null，RPF邻居地址为默认路由0.0.0.0


| 路由器 | (S, G) 地址对             | RPF邻居地址 | 上游接口 | 下游接口 |
| ------ | ------------------------- | ----------- | -------- | -------- |
| R1     | (172.16.1.1, 230.80.1.1)  | 172.16.7.21 | b        | a        |
| R2     | (172.16.1.1, 230.80.1.1) | 172.16.2.6  | a        | c        |
| R3     | (172.16.1.1, 230.80.1.1) | 172.16.3.10 | c        | a        |
| R4     | (172.16.1.1, 230.80.1.1) | 172.16.5.14 | c        | b        |
| R5     | (172.16.1.1, 230.80.1.1) | 172.16.7.22 | c        | a, b     |
| R6     | (172.16.1.1, 230.80.1.1) | 0.0.0.0     | Null     | a        |

